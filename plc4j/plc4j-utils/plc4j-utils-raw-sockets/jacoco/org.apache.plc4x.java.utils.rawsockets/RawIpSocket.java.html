<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>RawIpSocket.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">PLC4J: Utils: Raw-Sockets</a> &gt; <a href="index.source.html" class="el_package">org.apache.plc4x.java.utils.rawsockets</a> &gt; <span class="el_source">RawIpSocket.java</span></div><h1>RawIpSocket.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2014 The Netty Project
 *
 * The Netty Project licenses this file to you under the Apache License,
 * version 2.0 (the &quot;License&quot;); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at:
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations
 * under the License.
 */
package org.apache.plc4x.java.utils.rawsockets;

import org.apache.commons.lang3.SystemUtils;
import org.pcap4j.core.*;
import org.pcap4j.packet.*;
import org.pcap4j.packet.namednumber.*;
import org.pcap4j.util.ByteArrays;
import org.pcap4j.util.LinkLayerAddress;
import org.pcap4j.util.MacAddress;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.Inet4Address;
import java.net.InetAddress;
import java.net.UnknownHostException;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.concurrent.*;

public class RawIpSocket {

<span class="nc" id="L42">    private static final Logger logger = LoggerFactory.getLogger(RawIpSocket.class);</span>

    private static final int SNAPLEN = 65536;
    private static final int READ_TIMEOUT = 10;

    private static final String GATEWAY_ONLY_NETMASK = &quot;255.255.255.255&quot;;

<span class="nc" id="L49">    private static final Map&lt;InetAddress, MacAddress&gt; arpCache = new HashMap&lt;&gt;();</span>

    // The id of the protocol we will be communicating in.
    private final int protocolNumber;

    private PcapNetworkInterface nif;
    private InetAddress remoteIpAddress;
    private MacAddress firstHopMacAddress;
    private InetAddress localIpAddress;
    private MacAddress localMacAddress;
<span class="nc" id="L59">    private ExecutorService pool = Executors.newSingleThreadExecutor();</span>
    private PcapHandle receiveHandle;

<span class="nc" id="L62">    private final List&lt;RawSocketListener&gt; listeners = new LinkedList&lt;&gt;();</span>

<span class="nc" id="L64">    public RawIpSocket(int protocolNumber) {</span>
<span class="nc" id="L65">        this.protocolNumber = protocolNumber;</span>
<span class="nc" id="L66">    }</span>

    public void connect(String remoteAddress) throws RawSocketException {
        try {
<span class="nc" id="L70">            pool = Executors.newScheduledThreadPool(2);</span>

<span class="nc" id="L72">            remoteIpAddress = InetAddress.getByName(remoteAddress);</span>

            // As we have to create the Ethernet packets ourselves, and
            // in case of non local remote addresses we need to go through
            // routers and gateways, we need do differentiate between the
            // next ethernet node and the remote ip address.
            //
            // We therefore need to know the following information:
            // 1. Can we connect to the remote directly (a) or do we
            //    need a gateway (b)?
            // 2. The local IP and Mac Address of our device
            // 3a. The remote IP and Mac address of the target device
            // 3b. The remote IP of the target device &amp; the Mac address
            //     of the gateway.

            // Check if we can connect directly to the destination.
<span class="nc" id="L88">            FirstHop firstHop = getFirstHop(remoteIpAddress);</span>
<span class="nc bnc" id="L89" title="All 2 branches missed.">            if (firstHop == null) {</span>
                // If this wouldn't work, try to figure out the default
                // gateway and use that as next hop.
<span class="nc" id="L92">                InetAddress defaultGatewayAddress = getDefaultGatewayAddress();</span>
<span class="nc bnc" id="L93" title="All 2 branches missed.">                if (defaultGatewayAddress != null) {</span>
<span class="nc" id="L94">                    firstHop = getFirstHop(defaultGatewayAddress);</span>
<span class="nc bnc" id="L95" title="All 2 branches missed.">                    if (firstHop == null) {</span>
                        // If this didn't work, we simply can't reach the
                        // destination and give up with an exception. Not
                        // much we can do here.
<span class="nc" id="L99">                        throw new RawSocketException(&quot;Unable to connect to &quot; + remoteAddress);</span>
                    }
                } else {
<span class="nc" id="L102">                    throw new RawSocketException(&quot;Unable to connect to &quot; + remoteAddress + &quot; no default gateway&quot;);</span>
                }
            }

<span class="nc" id="L106">            nif = firstHop.networkInterface;</span>

<span class="nc bnc" id="L108" title="All 2 branches missed.">            if (nif.isLoopBack()) {</span>
<span class="nc" id="L109">                throw new RawSocketException(&quot;Can't use RawSocket on loopback devices&quot;);</span>
            }

<span class="nc" id="L112">            localMacAddress = MacAddress.getByAddress(firstHop.localMacAddress.getAddress());</span>
<span class="nc" id="L113">            localIpAddress = firstHop.localInetAddress;</span>

<span class="nc" id="L115">            firstHopMacAddress = MacAddress.getByAddress(firstHop.remoteMacAddress.getAddress());</span>

            // Setup receiving of packets and redirecting them to the corresponding listeners.
            // Filter packets to contain only the ip protocol number of the current protocol.
<span class="nc" id="L119">            receiveHandle = nif.openLive(SNAPLEN, PcapNetworkInterface.PromiscuousMode.PROMISCUOUS, READ_TIMEOUT);</span>

            // Set the filter.
<span class="nc" id="L122">            String filterString = &quot;ip protochain &quot; + protocolNumber +</span>
<span class="nc" id="L123">                &quot; and ether dst &quot; + localMacAddress.toString() +</span>
<span class="nc" id="L124">                &quot; and ip dst &quot; + localIpAddress.getHostAddress() +</span>
<span class="nc" id="L125">                &quot; and ether src &quot; + firstHopMacAddress.toString() +</span>
<span class="nc" id="L126">                &quot; and ip src &quot; + remoteIpAddress.getHostAddress();</span>

<span class="nc" id="L128">            receiveHandle.setFilter(filterString, BpfProgram.BpfCompileMode.OPTIMIZE);</span>
<span class="nc" id="L129">            PacketListener packetListener = packet -&gt; {</span>
<span class="nc bnc" id="L130" title="All 2 branches missed.">                for (RawSocketListener listener : listeners) {</span>
<span class="nc" id="L131">                    listener.packetReceived(packet.getRawData());</span>
<span class="nc" id="L132">                }</span>
<span class="nc" id="L133">            };</span>

<span class="nc" id="L135">            pool.execute(() -&gt; {</span>
                try {
<span class="nc" id="L137">                    receiveHandle.loop(-1, packetListener);</span>
<span class="nc" id="L138">                } catch (PcapNativeException | InterruptedException | NotOpenException e) {</span>
<span class="nc" id="L139">                    logger.error(&quot;Error receiving packet for protocol {} from MAC address {}&quot;,</span>
<span class="nc" id="L140">                        protocolNumber, firstHopMacAddress, e);</span>
<span class="nc" id="L141">                }</span>
<span class="nc" id="L142">            });</span>
<span class="nc" id="L143">        } catch (PcapNativeException | NotOpenException | UnknownHostException e) {</span>
<span class="nc" id="L144">            throw new RawSocketException(&quot;Error setting up RawSocket&quot;, e);</span>
<span class="nc" id="L145">        }</span>
<span class="nc" id="L146">    }</span>

    public void disconnect() throws RawSocketException {
        // TODO: Terminate all the listeners and the thread pool.
<span class="nc" id="L150">    }</span>

    public void write(byte[] rawData) throws RawSocketException {
<span class="nc" id="L153">        try (PcapHandle sendHandle =</span>
<span class="nc" id="L154">                 nif.openLive(SNAPLEN, PcapNetworkInterface.PromiscuousMode.PROMISCUOUS, READ_TIMEOUT)) {</span>
<span class="nc" id="L155">            UnknownPacket.Builder packetBuilder = new UnknownPacket.Builder();</span>
<span class="nc" id="L156">            packetBuilder.rawData(rawData);</span>

<span class="nc" id="L158">            IpV4Packet.Builder ipV4Builder = new IpV4Packet.Builder();</span>
<span class="nc" id="L159">            ipV4Builder</span>
<span class="nc" id="L160">                .version(IpVersion.IPV4)</span>
<span class="nc" id="L161">                .tos(IpV4Rfc791Tos.newInstance((byte) 0))</span>
<span class="nc" id="L162">                .ttl((byte) 100)</span>
<span class="nc" id="L163">                .protocol(new IpNumber((byte) protocolNumber, &quot;plc4x&quot;))</span>
<span class="nc" id="L164">                .srcAddr((Inet4Address) localIpAddress)</span>
<span class="nc" id="L165">                .dstAddr((Inet4Address) remoteIpAddress)</span>
<span class="nc" id="L166">                .payloadBuilder(packetBuilder)</span>
<span class="nc" id="L167">                .correctChecksumAtBuild(true)</span>
<span class="nc" id="L168">                .correctLengthAtBuild(true);</span>
<span class="nc" id="L169">            ipV4Builder.identification((short) 1);</span>

<span class="nc" id="L171">            EthernetPacket.Builder etherBuilder = new EthernetPacket.Builder();</span>
<span class="nc" id="L172">            etherBuilder.dstAddr(firstHopMacAddress)</span>
<span class="nc" id="L173">                .srcAddr(localMacAddress)</span>
<span class="nc" id="L174">                .type(EtherType.IPV4)</span>
<span class="nc" id="L175">                .paddingAtBuild(true);</span>
<span class="nc" id="L176">            etherBuilder.payloadBuilder(</span>
<span class="nc" id="L177">                new AbstractPacket.AbstractBuilder() {</span>
                    @Override
                    public Packet build() {
<span class="nc" id="L180">                        return ipV4Builder.build();</span>
                    }
                }
            );

<span class="nc" id="L185">            Packet p = etherBuilder.build();</span>
<span class="nc" id="L186">            sendHandle.sendPacket(p);</span>
<span class="nc" id="L187">        } catch (PcapNativeException | NotOpenException e) {</span>
<span class="nc" id="L188">            throw new RawSocketException(&quot;Error sending packet.&quot;, e);</span>
<span class="nc" id="L189">        }</span>
<span class="nc" id="L190">    }</span>

    public void addListener(RawSocketListener listener) {
<span class="nc" id="L193">        listeners.add(listener);</span>
<span class="nc" id="L194">    }</span>

    public void removeListener(RawSocketListener listener) {
<span class="nc" id="L197">        listeners.remove(listener);</span>
<span class="nc" id="L198">    }</span>

    private MacAddress getMacAddress(PcapNetworkInterface dev, InetAddress localIpAddress, InetAddress remoteIpAddress) throws RawSocketException {
<span class="nc bnc" id="L201" title="All 2 branches missed.">        if (!arpCache.containsKey(remoteIpAddress)) {</span>
<span class="nc" id="L202">            MacAddress macAddress = lookupMacAddress(dev, localIpAddress, remoteIpAddress);</span>
<span class="nc" id="L203">            arpCache.put(remoteIpAddress, macAddress);</span>
<span class="nc" id="L204">            return macAddress;</span>
        }
<span class="nc" id="L206">        return arpCache.get(remoteIpAddress);</span>
    }

    private MacAddress lookupMacAddress(PcapNetworkInterface dev, InetAddress localIpAddress, InetAddress remoteIpAddress) throws RawSocketException {
        try {
<span class="nc" id="L211">            PcapHandle receiveHandle =</span>
<span class="nc" id="L212">                dev.openLive(SNAPLEN, PcapNetworkInterface.PromiscuousMode.PROMISCUOUS, READ_TIMEOUT);</span>
<span class="nc" id="L213">            PcapHandle sendHandle =</span>
<span class="nc" id="L214">                dev.openLive(SNAPLEN, PcapNetworkInterface.PromiscuousMode.PROMISCUOUS, READ_TIMEOUT);</span>
            try {
                // Setup the filter to accept only the arp packets sent back to the current
                // host from the address of the remote host we wanted to get the mac address
                // from.
<span class="nc" id="L219">                receiveHandle.setFilter(</span>
<span class="nc" id="L220">                    &quot;arp and src host &quot; + remoteIpAddress.getHostAddress()</span>
<span class="nc" id="L221">                        + &quot; and dst host &quot; + localIpAddress.getHostAddress(),</span>
                    BpfProgram.BpfCompileMode.OPTIMIZE
                );

<span class="nc" id="L225">                CompletableFuture&lt;MacAddress&gt; resolutionFuture = new CompletableFuture&lt;&gt;();</span>
<span class="nc" id="L226">                PacketListener listener</span>
                    = packet -&gt; {
<span class="nc bnc" id="L228" title="All 2 branches missed.">                    if (packet.contains(ArpPacket.class)) {</span>
<span class="nc" id="L229">                        ArpPacket arp = packet.get(ArpPacket.class);</span>
<span class="nc bnc" id="L230" title="All 2 branches missed.">                        if (arp.getHeader().getOperation().equals(ArpOperation.REPLY)) {</span>
<span class="nc" id="L231">                            resolutionFuture.complete(arp.getHeader().getSrcHardwareAddr());</span>
                        }
                    }
<span class="nc" id="L234">                };</span>

<span class="nc" id="L236">                pool.execute(() -&gt; {</span>
                    try {
<span class="nc" id="L238">                        receiveHandle.loop(-1, listener);</span>
<span class="nc" id="L239">                    } catch (PcapNativeException | InterruptedException | NotOpenException e) {</span>
<span class="nc" id="L240">                        logger.error(&quot;Error receiving ARP lookup&quot;, e);</span>
<span class="nc" id="L241">                    }</span>
<span class="nc" id="L242">                });</span>

<span class="nc" id="L244">                MacAddress localMacAddress = MacAddress.getByAddress(</span>
<span class="nc" id="L245">                    dev.getLinkLayerAddresses().iterator().next().getAddress());</span>
<span class="nc" id="L246">                ArpPacket.Builder arpBuilder = new ArpPacket.Builder();</span>
<span class="nc" id="L247">                arpBuilder</span>
<span class="nc" id="L248">                    .hardwareType(ArpHardwareType.ETHERNET)</span>
<span class="nc" id="L249">                    .protocolType(EtherType.IPV4)</span>
<span class="nc" id="L250">                    .hardwareAddrLength((byte) MacAddress.SIZE_IN_BYTES)</span>
<span class="nc" id="L251">                    .protocolAddrLength((byte) ByteArrays.INET4_ADDRESS_SIZE_IN_BYTES)</span>
<span class="nc" id="L252">                    .operation(ArpOperation.REQUEST)</span>
<span class="nc" id="L253">                    .srcHardwareAddr(localMacAddress)</span>
<span class="nc" id="L254">                    .srcProtocolAddr(localIpAddress)</span>
<span class="nc" id="L255">                    .dstHardwareAddr(MacAddress.ETHER_BROADCAST_ADDRESS)</span>
<span class="nc" id="L256">                    .dstProtocolAddr(remoteIpAddress);</span>

<span class="nc" id="L258">                EthernetPacket.Builder etherBuilder = new EthernetPacket.Builder();</span>
<span class="nc" id="L259">                etherBuilder.dstAddr(MacAddress.ETHER_BROADCAST_ADDRESS)</span>
<span class="nc" id="L260">                    .srcAddr(localMacAddress)</span>
<span class="nc" id="L261">                    .type(EtherType.ARP)</span>
<span class="nc" id="L262">                    .payloadBuilder(arpBuilder)</span>
<span class="nc" id="L263">                    .paddingAtBuild(true);</span>

<span class="nc" id="L265">                Packet p = etherBuilder.build();</span>
<span class="nc" id="L266">                sendHandle.sendPacket(p);</span>
                try {
<span class="nc" id="L268">                    return resolutionFuture.get(3000, TimeUnit.MILLISECONDS);</span>
<span class="nc" id="L269">                } catch (TimeoutException e) {</span>
<span class="nc" id="L270">                    logger.info(&quot;Couldn't resolve MAC address for ip address {}&quot;, remoteIpAddress.getHostAddress(), e);</span>
<span class="nc" id="L271">                    return null;</span>
                }
            } finally {
<span class="nc bnc" id="L274" title="All 2 branches missed.">                if (sendHandle.isOpen()) {</span>
<span class="nc" id="L275">                    sendHandle.close();</span>
                }
<span class="nc bnc" id="L277" title="All 2 branches missed.">                if (receiveHandle.isOpen()) {</span>
                    // Terminate the receive loop first.
<span class="nc" id="L279">                    receiveHandle.breakLoop();</span>
<span class="nc" id="L280">                    receiveHandle.close();</span>
                }
            }
<span class="nc" id="L283">        } catch (PcapNativeException | InterruptedException | ExecutionException | NotOpenException e) {</span>
<span class="nc" id="L284">            throw new RawSocketException(&quot;Error looking up MAC address for ip address &quot; +</span>
<span class="nc" id="L285">                remoteIpAddress.getHostAddress() + &quot; on device &quot; + dev.getName(), e);</span>
        }
    }

    /**
     * Iterate through all devices and find the first that would be able to connect to the given address.
     *
     * @param remoteAddress address we want to connect to.
     * @return PcapNetworkInterface interface that should be able to connect to the given address.
     * @throws RawSocketException something went wrong.
     */
    private FirstHop getFirstHop(InetAddress remoteAddress) throws RawSocketException {
<span class="nc" id="L297">        byte[] remoteIp = remoteAddress.getAddress();</span>
        // Iterate over all network interfaces.
        try {
            // First try if we can connect to the remote device directly.
<span class="nc bnc" id="L301" title="All 2 branches missed.">            for (PcapNetworkInterface dev : Pcaps.findAllDevs()) {</span>
                // Iterate over all addresses configured for this interface.
<span class="nc bnc" id="L303" title="All 2 branches missed.">                for (PcapAddress localAddress : dev.getAddresses()) {</span>
<span class="nc bnc" id="L304" title="All 2 branches missed.">                    if(GATEWAY_ONLY_NETMASK.equals(localAddress.getNetmask().getHostAddress())) {</span>
<span class="nc" id="L305">                        return new FirstHop(dev, localAddress.getAddress(),</span>
<span class="nc" id="L306">                            dev.getLinkLayerAddresses().iterator().next(),</span>
<span class="nc" id="L307">                            getMacAddress(dev, localAddress.getAddress(), remoteAddress));</span>
                    }
                    // Only check addresses matching the IP-version of the remote address.
<span class="nc bnc" id="L310" title="All 2 branches missed.">                    if (remoteAddress.getClass().equals(localAddress.getAddress().getClass())) {</span>
<span class="nc" id="L311">                        byte[] localIp = localAddress.getAddress().getAddress();</span>
<span class="nc" id="L312">                        byte[] netMask = localAddress.getNetmask().getAddress();</span>
<span class="nc" id="L313">                        boolean matches = true;</span>
                        // Iterate over all bytes of the address and see if they match
                        // after applying the net mask filter.
<span class="nc bnc" id="L316" title="All 2 branches missed.">                        for (int i = 0; i &lt; localIp.length; i++) {</span>
<span class="nc bnc" id="L317" title="All 2 branches missed.">                            if ((localIp[i] &amp; netMask[i]) != (remoteIp[i] &amp; netMask[i])) {</span>
<span class="nc" id="L318">                                matches = false;</span>
<span class="nc" id="L319">                                break;</span>
                            }
                        }
                        // If the current address would be able to connect to the remote
                        // address, return this device.
<span class="nc bnc" id="L324" title="All 2 branches missed.">                        if (matches) {</span>
<span class="nc" id="L325">                            return new FirstHop(dev, localAddress.getAddress(),</span>
<span class="nc" id="L326">                                dev.getLinkLayerAddresses().iterator().next(),</span>
<span class="nc" id="L327">                                getMacAddress(dev, localAddress.getAddress(), remoteAddress));</span>
                        }
                    }
<span class="nc" id="L330">                }</span>
<span class="nc" id="L331">            }</span>
<span class="nc" id="L332">            return null;</span>
<span class="nc" id="L333">        } catch (PcapNativeException e) {</span>
<span class="nc" id="L334">            throw new RawSocketException(&quot;Error finding a device to communicate with remote address.&quot;, e);</span>
        }
    }

    /**
     * Unfortunately there is no way to get the ip address of the default gateway the
     * system uses to route traffic to remote networks. Luckily the 'netstat' command
     * is available on all systems and the only difference is the output. So in this
     * case we fallback to executing this command and parsing it's output depending on
     * the system it is run on.
     *
     * @return InetAddress representing the address of the internet gateway.
     */
    @SuppressWarnings(&quot;squid:S1313&quot;)
    private InetAddress getDefaultGatewayAddress() {
        try {
<span class="nc" id="L350">            Runtime rt = Runtime.getRuntime();</span>
<span class="nc" id="L351">            String[] commands = {&quot;netstat&quot;, &quot;-rn&quot;};</span>
<span class="nc" id="L352">            Process proc = rt.exec(commands);</span>

<span class="nc" id="L354">            BufferedReader stdInput = new BufferedReader(new InputStreamReader(proc.getInputStream()));</span>

            String linePrefix;
            int gatewayColumn;
<span class="nc bnc" id="L358" title="All 2 branches missed.">            if (SystemUtils.IS_OS_WINDOWS) {</span>
<span class="nc" id="L359">                linePrefix = &quot;0.0.0.0&quot;;</span>
<span class="nc" id="L360">                gatewayColumn = 2;</span>
<span class="nc bnc" id="L361" title="All 2 branches missed.">            } else if (SystemUtils.IS_OS_MAC_OSX) {</span>
<span class="nc" id="L362">                linePrefix = &quot;default&quot;;</span>
<span class="nc" id="L363">                gatewayColumn = 1;</span>
<span class="nc bnc" id="L364" title="All 2 branches missed.">            } else if (SystemUtils.IS_OS_LINUX) {</span>
<span class="nc" id="L365">                linePrefix = &quot;0.0.0.0&quot;;</span>
<span class="nc" id="L366">                gatewayColumn = 1;</span>
            } else {
<span class="nc" id="L368">                return null;</span>
            }

            String s;
<span class="nc bnc" id="L372" title="All 2 branches missed.">            while ((s = stdInput.readLine()) != null) {</span>
<span class="nc bnc" id="L373" title="All 2 branches missed.">                if (s.trim().startsWith(linePrefix)) {</span>
<span class="nc" id="L374">                    String[] columns = s.trim().split(&quot;\\s+&quot;);</span>
<span class="nc" id="L375">                    return InetAddress.getByName(columns[gatewayColumn]);</span>
                }
            }
<span class="nc" id="L378">        } catch (IOException e) {</span>
<span class="nc" id="L379">            logger.debug(&quot;error caught&quot;, e);</span>
<span class="nc" id="L380">            return null;</span>
<span class="nc" id="L381">        }</span>

        // Command on all platforms: &quot;netstat -rn&quot;

        /* Windows 7: line.trim().startsWith(&quot;0.0.0.0&quot;)

===========================================================================
Schnittstellenliste
 14...00 1c 42 98 16 7d ......Intel(R) PRO/1000 MT-Netzwerkverbindung #2
 11...00 1c 42 2e f3 40 ......Intel(R) PRO/1000 MT-Netzwerkverbindung
  1...........................Software Loopback Interface 1
 13...00 00 00 00 00 00 00 e0 Microsoft-ISATAP-Adapter
 12...00 00 00 00 00 00 00 e0 Teredo Tunneling Pseudo-Interface
 15...00 00 00 00 00 00 00 e0 Microsoft-ISATAP-Adapter #2
===========================================================================

IPv4-Routentabelle
===========================================================================
Aktive Routen:
     Netzwerkziel    Netzwerkmaske          Gateway    Schnittstelle Metrik
          0.0.0.0          0.0.0.0      10.211.55.1      10.211.55.3     10
      10.211.55.0    255.255.255.0   Auf Verbindung       10.211.55.3    266
      10.211.55.3  255.255.255.255   Auf Verbindung       10.211.55.3    266
    10.211.55.255  255.255.255.255   Auf Verbindung       10.211.55.3    266
        127.0.0.0        255.0.0.0   Auf Verbindung         127.0.0.1    306
        127.0.0.1  255.255.255.255   Auf Verbindung         127.0.0.1    306
  127.255.255.255  255.255.255.255   Auf Verbindung         127.0.0.1    306
      192.168.0.0      255.255.0.0   Auf Verbindung      192.168.0.43    266
     192.168.0.43  255.255.255.255   Auf Verbindung      192.168.0.43    266
  192.168.255.255  255.255.255.255   Auf Verbindung      192.168.0.43    266
        224.0.0.0        240.0.0.0   Auf Verbindung         127.0.0.1    306
        224.0.0.0        240.0.0.0   Auf Verbindung       10.211.55.3    266
        224.0.0.0        240.0.0.0   Auf Verbindung      192.168.0.43    266
  255.255.255.255  255.255.255.255   Auf Verbindung         127.0.0.1    306
  255.255.255.255  255.255.255.255   Auf Verbindung       10.211.55.3    266
  255.255.255.255  255.255.255.255   Auf Verbindung      192.168.0.43    266
===========================================================================
Ständige Routen:
  Keine

IPv6-Routentabelle
===========================================================================
Aktive Routen:
 If Metrik Netzwerkziel             Gateway
 11    266 ::/0                     fe80::21c:42ff:fe00:18
  1    306 ::1/128                  Auf Verbindung
 11     18 fdb2:2c26:f4e4::/64      Auf Verbindung
 11    266 fdb2:2c26:f4e4:0:24b4:9398:1a69:664/128
                                    Auf Verbindung
 11    266 fdb2:2c26:f4e4:0:7147:34d4:e033:a879/128
                                    Auf Verbindung
 14     18 fdb2:2c26:f4e4:1::/64    Auf Verbindung
 14    266 fdb2:2c26:f4e4:1:797d:18a9:3dd6:8105/128
                                    Auf Verbindung
 14    266 fdb2:2c26:f4e4:1:bcd1:eeb5:c8c1:cf05/128
                                    Auf Verbindung
 11    266 fe80::/64                Auf Verbindung
 14    266 fe80::/64                Auf Verbindung
 11    266 fe80::7147:34d4:e033:a879/128
                                    Auf Verbindung
 14    266 fe80::797d:18a9:3dd6:8105/128
                                    Auf Verbindung
  1    306 ff00::/8                 Auf Verbindung
 11    266 ff00::/8                 Auf Verbindung
 14    266 ff00::/8                 Auf Verbindung
===========================================================================
Ständige Routen:
  Keine


        Windows 10

===========================================================================
Schnittstellenliste
 14...00 1c 42 98 16 7d ......Intel(R) PRO/1000 MT-Netzwerkverbindung #2
 11...00 1c 42 2e f3 40 ......Intel(R) PRO/1000 MT-Netzwerkverbindung
  1...........................Software Loopback Interface 1
 13...00 00 00 00 00 00 00 e0 Microsoft-ISATAP-Adapter
 12...00 00 00 00 00 00 00 e0 Teredo Tunneling Pseudo-Interface
 15...00 00 00 00 00 00 00 e0 Microsoft-ISATAP-Adapter #2
===========================================================================

IPv4-Routentabelle
===========================================================================
Aktive Routen:
     Netzwerkziel    Netzwerkmaske          Gateway    Schnittstelle Metrik
          0.0.0.0          0.0.0.0      10.211.55.1      10.211.55.3     10
      10.211.55.0    255.255.255.0   Auf Verbindung       10.211.55.3    266
      10.211.55.3  255.255.255.255   Auf Verbindung       10.211.55.3    266
    10.211.55.255  255.255.255.255   Auf Verbindung       10.211.55.3    266
        127.0.0.0        255.0.0.0   Auf Verbindung         127.0.0.1    306
        127.0.0.1  255.255.255.255   Auf Verbindung         127.0.0.1    306
  127.255.255.255  255.255.255.255   Auf Verbindung         127.0.0.1    306
      192.168.0.0      255.255.0.0   Auf Verbindung      192.168.0.43    266
     192.168.0.43  255.255.255.255   Auf Verbindung      192.168.0.43    266
  192.168.255.255  255.255.255.255   Auf Verbindung      192.168.0.43    266
        224.0.0.0        240.0.0.0   Auf Verbindung         127.0.0.1    306
        224.0.0.0        240.0.0.0   Auf Verbindung       10.211.55.3    266
        224.0.0.0        240.0.0.0   Auf Verbindung      192.168.0.43    266
  255.255.255.255  255.255.255.255   Auf Verbindung         127.0.0.1    306
  255.255.255.255  255.255.255.255   Auf Verbindung       10.211.55.3    266
  255.255.255.255  255.255.255.255   Auf Verbindung      192.168.0.43    266
===========================================================================
Ständige Routen:
  Keine

IPv6-Routentabelle
===========================================================================
Aktive Routen:
 If Metrik Netzwerkziel             Gateway
 11    266 ::/0                     fe80::21c:42ff:fe00:18
  1    306 ::1/128                  Auf Verbindung
 11     18 fdb2:2c26:f4e4::/64      Auf Verbindung
 11    266 fdb2:2c26:f4e4:0:24b4:9398:1a69:664/128
                                    Auf Verbindung
 11    266 fdb2:2c26:f4e4:0:7147:34d4:e033:a879/128
                                    Auf Verbindung
 14     18 fdb2:2c26:f4e4:1::/64    Auf Verbindung
 14    266 fdb2:2c26:f4e4:1:797d:18a9:3dd6:8105/128
                                    Auf Verbindung
 14    266 fdb2:2c26:f4e4:1:bcd1:eeb5:c8c1:cf05/128
                                    Auf Verbindung
 11    266 fe80::/64                Auf Verbindung
 14    266 fe80::/64                Auf Verbindung
 11    266 fe80::7147:34d4:e033:a879/128
                                    Auf Verbindung
 14    266 fe80::797d:18a9:3dd6:8105/128
                                    Auf Verbindung
  1    306 ff00::/8                 Auf Verbindung
 11    266 ff00::/8                 Auf Verbindung
 14    266 ff00::/8                 Auf Verbindung
===========================================================================
Ständige Routen:
  Keine


        Ubuntu: line.trim().startsWith(&quot;0.0.0.0&quot;)

Kernel IP routing table
Destination     Gateway         Genmask         Flags   MSS Window  irtt Iface
0.0.0.0         10.211.55.1     0.0.0.0         UG        0 0          0 enp0s5
10.211.55.0     0.0.0.0         255.255.255.0   U         0 0          0 enp0s5
169.254.0.0     0.0.0.0         255.255.0.0     U         0 0          0 enp0s5

        Mac: line.trim().startsWith(&quot;default&quot;)

Routing tables

Internet:
Destination        Gateway            Flags        Refs      Use   Netif Expire
default            10.10.56.1         UGSc          109     1893     en0
10.10.56/24        link#9             UCS             0        0     en0
10.10.56.1/32      link#9             UCS             3        0     en0
10.10.56.1         0:90:7f:a2:7a:a3   UHLWIir        39       16     en0   1188
10.10.56.8/32      link#9             UCS             1        0     en0
10.10.56.8         8c:85:90:18:6f:a9  UHLWI           0        5     lo0
10.37.129/24       link#22            UC              1        0   vnic1
10.211.55/24       link#21            UC              2        0   vnic0
10.211.55.3        0:1c:42:2e:f3:40   UHLWIi          1        0   vnic0   1120
10.211.55.4        0:1c:42:ec:9d:4d   UHLWI           0        0   vnic0   1075
127                127.0.0.1          UCS             0        0     lo0
127.0.0.1          127.0.0.1          UH             26   320774     lo0
169.254            link#9             UCS             1        0     en0
169.254            link#7             UCSI            0        0     en7
169.254            link#20            UCSI            1        0     en8
169.254.233.80/32  link#20            UCS             0        0     en8
169.254.255.255    link#9             UHLSW           6       30     en0
192.168.0/16       link#7             UCS             1        0     en7
192.168.0.99/32    link#7             UCS             1        0     en7
192.168.42.1       link#7             UHLWIi          1       10     en7
224.0.0/4          link#9             UmCS            3        0     en0
224.0.0/4          link#7             UmCSI           1        0     en7
224.0.0/4          link#20            UmCSI           1        0     en8
224.0.0.251        1:0:5e:0:0:fb      UHmLWI          0      106     en0
224.0.0.252        1:0:5e:0:0:fc      UHmLWI          0       32     en0
239.255.255.250    1:0:5e:7f:ff:fa    UHmLWI          0      124     en7
239.255.255.250    1:0:5e:7f:ff:fa    UHmLWI          0      682     en0
239.255.255.250    1:0:5e:7f:ff:fa    UHmLWI          0       64     en8
255.255.255.255/32 link#9             UCS             0        0     en0
255.255.255.255/32 link#7             UCSI            0        0     en7
255.255.255.255/32 link#20            UCSI            0        0     en8

Internet6:
Destination                             Gateway                         Flags         Netif Expire
default                                 fe80::%utun0                    UGcI          utun0
default                                 fe80::%utun1                    UGcI          utun1
::1                                     ::1                             UHL             lo0
fe80::%lo0/64                           fe80::1%lo0                     UcI             lo0
fe80::1%lo0                             link#1                          UHLI            lo0
fe80::%en7/64                           link#7                          UCI             en7
fe80::4a8:61b9:6131:3848%en7            48:65:ee:12:d2:c7               UHLI            lo0
fe80::%en5/64                           link#8                          UCI             en5
fe80::aede:48ff:fe00:1122%en5           ac:de:48:0:11:22                UHLI            lo0
fe80::aede:48ff:fe33:4455%en5           ac:de:48:33:44:55               UHLWIi          en5
fe80::%en0/64                           link#9                          UCI             en0
fe80::10cf:c2ea:7baa:626b%en0           8c:85:90:18:6f:a9               UHLI            lo0
fe80::%awdl0/64                         link#11                         UCI           awdl0
fe80::cbd:62ff:fe3e:406c%awdl0          e:bd:62:3e:40:6c                UHLI            lo0
fe80::%utun0/64                         fe80::3a17:f866:7728:6e8d%utun0 UcI           utun0
fe80::3a17:f866:7728:6e8d%utun0         link#17                         UHLI            lo0
fe80::%utun1/64                         fe80::eb7a:3ecf:562c:167b%utun1 UcI           utun1
fe80::eb7a:3ecf:562c:167b%utun1         link#18                         UHLI            lo0
fe80::%en8/64                           link#20                         UCI             en8
fe80::415:f342:498d:14d2%en8            42:4d:7f:8a:b3:83               UHLI            lo0
ff01::%lo0/32                           ::1                             UmCI            lo0
ff01::%en7/32                           link#7                          UmCI            en7
ff01::%en5/32                           link#8                          UmCI            en5
ff01::%en0/32                           link#9                          UmCI            en0
ff01::%awdl0/32                         link#11                         UmCI          awdl0
ff01::%utun0/32                         fe80::3a17:f866:7728:6e8d%utun0 UmCI          utun0
ff01::%utun1/32                         fe80::eb7a:3ecf:562c:167b%utun1 UmCI          utun1
ff01::%en8/32                           link#20                         UmCI            en8
ff02::%lo0/32                           ::1                             UmCI            lo0
ff02::%en7/32                           link#7                          UmCI            en7
ff02::%en5/32                           link#8                          UmCI            en5
ff02::%en0/32                           link#9                          UmCI            en0
ff02::%awdl0/32                         link#11                         UmCI          awdl0
ff02::%utun0/32                         fe80::3a17:f866:7728:6e8d%utun0 UmCI          utun0
ff02::%utun1/32                         fe80::eb7a:3ecf:562c:167b%utun1 UmCI          utun1
ff02::%en8/32                           link#20                         UmCI            en8


         */
<span class="nc" id="L604">        return null;</span>
    }

    private static class FirstHop {
        private final PcapNetworkInterface networkInterface;
        private final InetAddress localInetAddress;
        private final LinkLayerAddress localMacAddress;
        private final LinkLayerAddress remoteMacAddress;

        private FirstHop(PcapNetworkInterface networkInterface, InetAddress localInetAddress, LinkLayerAddress localMacAddress,
<span class="nc" id="L614">                         LinkLayerAddress remoteMacAddress) {</span>
<span class="nc" id="L615">            this.networkInterface = networkInterface;</span>
<span class="nc" id="L616">            this.localInetAddress = localInetAddress;</span>
<span class="nc" id="L617">            this.localMacAddress = localMacAddress;</span>
<span class="nc" id="L618">            this.remoteMacAddress = remoteMacAddress;</span>
<span class="nc" id="L619">        }</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>