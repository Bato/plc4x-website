<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>S7Protocol.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">PLC4J: Protocol: S7</a> &gt; <a href="index.source.html" class="el_package">org.apache.plc4x.java.s7.netty</a> &gt; <span class="el_source">S7Protocol.java</span></div><h1>S7Protocol.java</h1><pre class="source lang-java linenums">/*
Licensed to the Apache Software Foundation (ASF) under one
or more contributor license agreements.  See the NOTICE file
distributed with this work for additional information
regarding copyright ownership.  The ASF licenses this file
to you under the Apache License, Version 2.0 (the
&quot;License&quot;); you may not use this file except in compliance
with the License.  You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing,
software distributed under the License is distributed on an
&quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, either express or implied.  See the License for the
specific language governing permissions and limitations
under the License.
*/
package org.apache.plc4x.java.s7.netty;

import io.netty.buffer.ByteBuf;
import io.netty.buffer.ByteBufUtil;
import io.netty.buffer.Unpooled;
import io.netty.channel.*;
import io.netty.handler.codec.MessageToMessageDecoder;
import io.netty.util.concurrent.Future;
import io.netty.util.concurrent.PromiseCombiner;
import org.apache.commons.lang3.reflect.FieldUtils;
import org.apache.plc4x.java.api.exceptions.PlcProtocolException;
import org.apache.plc4x.java.api.exceptions.PlcProtocolPayloadTooBigException;
import org.apache.plc4x.java.isotp.protocol.IsoTPProtocol;
import org.apache.plc4x.java.isotp.protocol.events.IsoTPConnectedEvent;
import org.apache.plc4x.java.isotp.protocol.model.IsoTPMessage;
import org.apache.plc4x.java.isotp.protocol.model.tpdus.DataTpdu;
import org.apache.plc4x.java.s7.netty.events.S7ConnectedEvent;
import org.apache.plc4x.java.s7.netty.model.messages.S7Message;
import org.apache.plc4x.java.s7.netty.model.messages.S7RequestMessage;
import org.apache.plc4x.java.s7.netty.model.messages.S7ResponseMessage;
import org.apache.plc4x.java.s7.netty.model.messages.SetupCommunicationRequestMessage;
import org.apache.plc4x.java.s7.netty.model.params.*;
import org.apache.plc4x.java.s7.netty.model.params.items.S7AnyVarParameterItem;
import org.apache.plc4x.java.s7.netty.model.params.items.VarParameterItem;
import org.apache.plc4x.java.s7.netty.model.payloads.CpuServicesPayload;
import org.apache.plc4x.java.s7.netty.model.payloads.S7Payload;
import org.apache.plc4x.java.s7.netty.model.payloads.VarPayload;
import org.apache.plc4x.java.s7.netty.model.payloads.items.VarPayloadItem;
import org.apache.plc4x.java.s7.netty.model.payloads.ssls.SslDataRecord;
import org.apache.plc4x.java.s7.netty.model.payloads.ssls.SslModuleIdentificationDataRecord;
import org.apache.plc4x.java.s7.netty.model.types.*;
import org.apache.plc4x.java.s7.netty.strategies.S7MessageProcessor;
import org.apache.plc4x.java.s7.netty.util.S7SizeHelper;
import org.apache.plc4x.java.s7.types.S7ControllerType;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.lang.reflect.Field;
import java.nio.charset.StandardCharsets;
import java.util.*;

/**
 * Communication Layer between the Application level ({@link Plc4XS7Protocol}) and the lower level (tcp) that sends and receives {@link S7Message}s.
 * This layer also handles the control over the &quot;wire&quot;, i.e., the queues of incoming and outgoing messages.
 * Furthermore, here {@link S7Message}s are marshalled and unmarshalled to {@link ByteBuf}s to be send over wire.
 *
 * Before messages are send to the wire an optional {@link S7MessageProcessor} can be applied.
 *
 * @see S7MessageProcessor
 */
public class S7Protocol extends ChannelDuplexHandler {

    private static final byte S7_PROTOCOL_MAGIC_NUMBER = 0x32;

<span class="fc" id="L73">    private static final Logger logger = LoggerFactory.getLogger(S7Protocol.class);</span>

<span class="fc" id="L75">    private final MessageToMessageDecoder&lt;Object&gt; decoder = new MessageToMessageDecoder&lt;Object&gt;() {</span>

        @Override
        public boolean acceptInboundMessage(Object msg) {
<span class="nc" id="L79">            return msg instanceof IsoTPMessage;</span>
        }

        @Override
        @SuppressWarnings(&quot;unchecked&quot;)
        protected void decode(ChannelHandlerContext ctx, Object msg, List&lt;Object&gt; out) {
<span class="nc" id="L85">            S7Protocol.this.decode(ctx, (IsoTPMessage) msg, out);</span>
<span class="nc" id="L86">        }</span>
    };

    private short maxAmqCaller;
    private short maxAmqCallee;
    private short pduSize;
    private S7ControllerType controllerType;

    // For detecting the lower layers.
    private ChannelHandler prevChannelHandler;
    private S7MessageProcessor messageProcessor;

    // For being able to respect the max AMQ restrictions.
    private PendingWriteQueue queue;
    private Map&lt;Short, DataTpdu&gt; sentButUnacknowledgedTpdus;

    public S7Protocol(short requestedMaxAmqCaller, short requestedMaxAmqCallee, short requestedPduSize,
<span class="fc" id="L103">                      S7ControllerType controllerType, S7MessageProcessor messageProcessor) {</span>
<span class="fc" id="L104">        this.maxAmqCaller = requestedMaxAmqCaller;</span>
<span class="fc" id="L105">        this.maxAmqCallee = requestedMaxAmqCallee;</span>
<span class="fc" id="L106">        this.pduSize = requestedPduSize;</span>
<span class="fc" id="L107">        this.controllerType = controllerType;</span>
<span class="fc" id="L108">        this.messageProcessor = messageProcessor;</span>
<span class="fc" id="L109">        sentButUnacknowledgedTpdus = new HashMap&lt;&gt;();</span>
<span class="fc" id="L110">    }</span>

    @Override
    public void channelRegistered(ChannelHandlerContext ctx) {
<span class="fc" id="L114">        this.queue = new PendingWriteQueue(ctx);</span>
        try {
<span class="fc" id="L116">            Field prevField = FieldUtils.getField(ctx.getClass(), &quot;prev&quot;, true);</span>
<span class="pc bpc" id="L117" title="1 of 2 branches missed.">            if(prevField != null) {</span>
<span class="fc" id="L118">                ChannelHandlerContext prevContext = (ChannelHandlerContext) prevField.get(ctx);</span>
<span class="fc" id="L119">                prevChannelHandler = prevContext.handler();</span>
            }
<span class="nc" id="L121">        } catch(Exception e) {</span>
<span class="nc" id="L122">            logger.error(&quot;Error accessing field 'prev'&quot;, e);</span>
<span class="fc" id="L123">        }</span>
<span class="fc" id="L124">    }</span>

    @Override
    public void channelUnregistered(ChannelHandlerContext ctx) throws Exception {
<span class="nc" id="L128">        this.queue.removeAndWriteAll();</span>
<span class="nc" id="L129">        super.channelUnregistered(ctx);</span>
<span class="nc" id="L130">    }</span>

    @Override
    public void channelInactive(ChannelHandlerContext ctx) throws Exception {
        // Send everything so we get a proper failure for those pending writes
<span class="nc" id="L135">        this.queue.removeAndWriteAll();</span>
<span class="nc" id="L136">        super.channelInactive(ctx);</span>
<span class="nc" id="L137">    }</span>

    /**
     * If the S7 protocol layer is used over Iso TP, then after receiving a {@link IsoTPConnectedEvent} the
     * corresponding S7 setup communication message has to be sent in order to negotiate the S7 protocol layer.
     *
     * @param ctx the current protocol layers context
     * @param evt the event
     * @throws Exception throws an exception if something goes wrong internally
     */
    @Override
    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {
        // If we are using S7 inside of IsoTP, then we need to intercept IsoTPs connected events.
<span class="nc bnc" id="L150" title="All 4 branches missed.">        if ((prevChannelHandler instanceof IsoTPProtocol) &amp;&amp; (evt instanceof IsoTPConnectedEvent)) {</span>
            // Setup Communication
<span class="nc" id="L152">            SetupCommunicationRequestMessage setupCommunicationRequest =</span>
                new SetupCommunicationRequestMessage((short) 0, maxAmqCaller, maxAmqCallee, pduSize, null);

<span class="nc" id="L155">            ctx.channel().writeAndFlush(setupCommunicationRequest);</span>
<span class="nc" id="L156">        }</span>

        else {
<span class="nc" id="L159">            super.userEventTriggered(ctx, evt);</span>
        }
<span class="nc" id="L161">    }</span>

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Encoding
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    @Override
    public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) {
        try {
<span class="fc bfc" id="L170" title="All 2 branches covered.">            if(msg instanceof S7Message) {</span>
<span class="fc" id="L171">                S7Message in = (S7Message) msg;</span>

                // Give message processors to process the incoming message.
                Collection&lt;? extends S7Message&gt; messages;
<span class="pc bpc" id="L175" title="3 of 4 branches missed.">                if ((messageProcessor != null) &amp;&amp; (in instanceof S7RequestMessage)) {</span>
<span class="nc" id="L176">                    messages = messageProcessor.processRequest((S7RequestMessage) in, pduSize);</span>
                } else {
<span class="fc" id="L178">                    messages = Collections.singleton(in);</span>
                }

                // Create a promise that has to be called multiple times.
<span class="fc" id="L182">                PromiseCombiner promiseCombiner = new PromiseCombiner();</span>
<span class="fc bfc" id="L183" title="All 2 branches covered.">                for (S7Message message : messages) {</span>
<span class="fc" id="L184">                    ByteBuf buf = Unpooled.buffer();</span>
<span class="fc" id="L185">                    writeS7Message(promise.channel(), promiseCombiner, message, buf);</span>
<span class="fc" id="L186">                }</span>
<span class="fc" id="L187">                promiseCombiner.finish(promise);</span>

                // Start sending the queue content.
<span class="fc" id="L190">                trySendingMessages(ctx);</span>
<span class="fc" id="L191">            }</span>
            // Especially during the phase of connection establishment, we might be sending
            // messages of a lower level protocol, so if it's not S7, we forward it to the next
            // in the pipeline and hope it can handle it. If no layer can handle it Netty will
            // exceptionally complete the future.
            else {
<span class="fc" id="L197">                ctx.write(msg, promise);</span>
            }
<span class="fc" id="L199">        } catch (Exception e) {</span>
<span class="fc" id="L200">            promise.setFailure(e);</span>
<span class="fc" id="L201">        }</span>
<span class="fc" id="L202">    }</span>

    private void writeS7Message(Channel channel, PromiseCombiner promiseCombiner,
                                S7Message message, ByteBuf buf) throws PlcProtocolException {
<span class="fc" id="L206">        encodeHeader(message, buf);</span>
<span class="fc" id="L207">        encodeParameters(message, buf);</span>
<span class="fc" id="L208">        encodePayloads(message, buf);</span>

        // Check if the message doesn't exceed the negotiated maximum size.
<span class="fc bfc" id="L211" title="All 2 branches covered.">        if (buf.writerIndex() &gt; pduSize) {</span>
<span class="fc" id="L212">            throw new PlcProtocolPayloadTooBigException(&quot;s7&quot;, pduSize, buf.writerIndex(), message);</span>
        } else {
<span class="fc" id="L214">            ChannelPromise subPromise = new DefaultChannelPromise(channel);</span>
            // The tpduRef was 0x01 but had to be changed to 0x00 in order to support Siemens LOGO devices.
<span class="fc" id="L216">            queue.add(new DataTpdu(true, (byte) 0x00, Collections.emptyList(), buf, message), subPromise);</span>
<span class="fc" id="L217">            promiseCombiner.add((Future) subPromise);</span>
<span class="fc" id="L218">            logger.debug(&quot;S7 Message with id {} queued&quot;, message.getTpduReference());</span>
        }
<span class="fc" id="L220">    }</span>

    private void encodePayloads(S7Message in, ByteBuf buf) throws PlcProtocolException {
<span class="fc bfc" id="L223" title="All 2 branches covered.">        if(in.getPayloads() != null) {</span>
<span class="fc" id="L224">            Iterator&lt;S7Payload&gt; payloadIterator = in.getPayloads().iterator();</span>
<span class="fc bfc" id="L225" title="All 2 branches covered.">            while(payloadIterator.hasNext()) {</span>
<span class="fc" id="L226">                S7Payload payload = payloadIterator.next();</span>
<span class="fc bfc" id="L227" title="All 3 branches covered.">                switch (payload.getType()) {</span>
                    case WRITE_VAR:
<span class="pc bpc" id="L229" title="1 of 2 branches missed.">                        encodeWriteVarPayload((VarPayload) payload, buf, !payloadIterator.hasNext());</span>
<span class="fc" id="L230">                        break;</span>
                    case CPU_SERVICES:
<span class="fc" id="L232">                        encodeCpuServicesPayload((CpuServicesPayload) payload, buf);</span>
<span class="fc" id="L233">                        break;</span>
                    default:
<span class="fc" id="L235">                        throw new PlcProtocolException(&quot;Writing payloads of type &quot; +</span>
<span class="fc" id="L236">                            payload.getType().name() + &quot; not implemented.&quot;);</span>
                }
<span class="fc" id="L238">            }</span>
        }
<span class="fc" id="L240">    }</span>

    private void encodeWriteVarPayload(VarPayload varPayload, ByteBuf buf, boolean lastItem) {
<span class="fc bfc" id="L243" title="All 2 branches covered.">        for (VarPayloadItem payloadItem : varPayload.getItems()) {</span>
<span class="fc" id="L244">            buf.writeByte(payloadItem.getReturnCode().getCode());</span>
<span class="fc" id="L245">            buf.writeByte(payloadItem.getDataTransportSize().getCode());</span>
            // TODO: Check if this is correct?!?! Might be problems with sizeInBits = true/false
<span class="fc" id="L247">            buf.writeShort(payloadItem.getData().length);</span>
<span class="fc" id="L248">            buf.writeBytes(payloadItem.getData());</span>
            // if this is not the last item and it's payload is exactly one byte, we need to output a fill-byte.
<span class="pc bpc" id="L250" title="2 of 4 branches missed.">            if((payloadItem.getData().length == 1) &amp;&amp; !lastItem) {</span>
<span class="nc" id="L251">                buf.writeByte(0x00);</span>
            }
<span class="fc" id="L253">        }</span>
<span class="fc" id="L254">    }</span>

    private void encodeCpuServicesPayload(CpuServicesPayload cpuServicesPayload, ByteBuf buf)
            throws PlcProtocolException {
<span class="fc" id="L258">        buf.writeByte(cpuServicesPayload.getReturnCode().getCode());</span>
        // This seems to be constantly set to this.
<span class="fc" id="L260">        buf.writeByte(DataTransportSize.OCTET_STRING.getCode());</span>

        // A request payload is simple.
<span class="fc bfc" id="L263" title="All 2 branches covered.">        if (cpuServicesPayload.getSslDataRecords().isEmpty()) {</span>
<span class="fc" id="L264">            buf.writeShort(4);</span>
<span class="fc" id="L265">            buf.writeShort(cpuServicesPayload.getSslId().getCode());</span>
<span class="fc" id="L266">            buf.writeShort(cpuServicesPayload.getSslIndex());</span>
        }
        // The response payload contains a lot more information.
        else {
<span class="fc" id="L270">            throw new PlcProtocolException(&quot;Unexpected SZL Data Records&quot;);</span>
            /*short length = 8;
            short sizeOfDataItem = 0;
            for (SslDataRecord sslDataRecord : cpuServicesPayload.getSslDataRecords()) {
                sizeOfDataItem = (short) (sslDataRecord.getLengthInWords() * (short) 2);
                length += sizeOfDataItem;
            }
            buf.writeShort(length);
            buf.writeShort(cpuServicesPayload.getSslId().getCode());
            buf.writeShort(cpuServicesPayload.getSslIndex());
            buf.writeShort(sizeOfDataItem);
            buf.writeShort(cpuServicesPayload.getSslDataRecords().size());
            // Output any sort of ssl list items, if there are any.
            for (SslDataRecord sslDataRecord : cpuServicesPayload.getSslDataRecords()) {
                if(sslDataRecord instanceof SslModuleIdentificationDataRecord) {
                    SslModuleIdentificationDataRecord midr = (SslModuleIdentificationDataRecord) sslDataRecord;
                    buf.writeShort(midr.getIndex());
                    byte[] articleNumberBytes = midr.getArticleNumber().getBytes(StandardCharsets.UTF_8);
                    // An array full of 20 spaces.
                    byte[] data = new byte[]{0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
                        0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20};
                    // Copy max 20 bytes from the article number into the dest array.
                    System.arraycopy(articleNumberBytes, 0, data, 0, 20);
                    buf.writeBytes(data);
                    buf.writeShort(midr.getModuleOrOsVersion());
                    buf.writeShort(midr.getPgDescriptionFileVersion());
                }
            }*/
        }
<span class="fc" id="L299">    }</span>

    private void encodeParameters(S7Message in, ByteBuf buf) throws PlcProtocolException {
<span class="fc bfc" id="L302" title="All 2 branches covered.">        for (S7Parameter s7Parameter : in.getParameters()) {</span>
<span class="fc" id="L303">            buf.writeByte(s7Parameter.getType().getCode());</span>
<span class="fc bfc" id="L304" title="All 4 branches covered.">            switch (s7Parameter.getType()) {</span>
                case READ_VAR:
                case WRITE_VAR:
<span class="fc" id="L307">                    encodeParameterReadWriteVar(buf, (VarParameter) s7Parameter);</span>
<span class="fc" id="L308">                    break;</span>
                case SETUP_COMMUNICATION:
<span class="fc" id="L310">                    encodeParameterSetupCommunication(buf, (SetupCommunicationParameter) s7Parameter);</span>
<span class="fc" id="L311">                    break;</span>
                case CPU_SERVICES:
<span class="fc" id="L313">                    encodeCpuServicesParameter(buf, (CpuServicesParameter) s7Parameter);</span>
<span class="fc" id="L314">                    break;</span>
                default:
<span class="fc" id="L316">                    throw new PlcProtocolException(&quot;Writing parameters of type &quot; +</span>
<span class="fc" id="L317">                        s7Parameter.getType().name() + &quot; not implemented.&quot;);</span>
            }
<span class="fc" id="L319">        }</span>
<span class="fc" id="L320">    }</span>

    private void encodeHeader(S7Message in, ByteBuf buf) {
<span class="fc" id="L323">        buf.writeByte(S7_PROTOCOL_MAGIC_NUMBER);</span>
<span class="fc" id="L324">        buf.writeByte(in.getMessageType().getCode());</span>
        // Reserved (is always constant 0x0000)
<span class="fc" id="L326">        buf.writeShort((short) 0x0000);</span>
        // PDU Reference (Request Id, generated by the initiating node)
<span class="fc" id="L328">        buf.writeShort(in.getTpduReference());</span>
        // S7 message parameters length
<span class="fc" id="L330">        buf.writeShort(S7SizeHelper.getParametersLength(in.getParameters()));</span>
        // Data field length
<span class="fc" id="L332">        buf.writeShort(S7SizeHelper.getPayloadsLength(in.getPayloads()));</span>
        // Not sure why this is implemented, we should never be sending out responses.
        /*if (in instanceof S7ResponseMessage) {
            S7ResponseMessage s7ResponseMessage = (S7ResponseMessage) in;
            buf.writeByte(s7ResponseMessage.getErrorClass());
            buf.writeByte(s7ResponseMessage.getErrorCode());
        }*/
<span class="fc" id="L339">    }</span>

    private void encodeParameterSetupCommunication(ByteBuf buf, SetupCommunicationParameter s7Parameter) {
        // Reserved (is always constant 0x00)
<span class="fc" id="L343">        buf.writeByte((byte) 0x00);</span>
<span class="fc" id="L344">        buf.writeShort(s7Parameter.getMaxAmqCaller());</span>
<span class="fc" id="L345">        buf.writeShort(s7Parameter.getMaxAmqCallee());</span>
<span class="fc" id="L346">        buf.writeShort(s7Parameter.getPduLength());</span>
<span class="fc" id="L347">    }</span>

    private void encodeParameterReadWriteVar(ByteBuf buf, VarParameter s7Parameter) throws PlcProtocolException {
<span class="fc" id="L350">        List&lt;VarParameterItem&gt; items = s7Parameter.getItems();</span>
        // PlcReadRequestItem count (Read one variable at a time)
<span class="fc" id="L352">        buf.writeByte((byte) items.size());</span>
<span class="fc bfc" id="L353" title="All 2 branches covered.">        for (VarParameterItem item : items) {</span>
<span class="fc" id="L354">            VariableAddressingMode addressMode = item.getAddressingMode();</span>
<span class="fc bfc" id="L355" title="All 2 branches covered.">            if (addressMode == VariableAddressingMode.S7ANY) {</span>
<span class="fc" id="L356">                encodeS7AnyParameterItem(buf, (S7AnyVarParameterItem) item);</span>
            } else {
<span class="fc" id="L358">                throw new PlcProtocolException(&quot;Writing VarParameterItems with addressing mode &quot; +</span>
<span class="fc" id="L359">                    addressMode.name() + &quot; not implemented&quot;);</span>
            }
<span class="fc" id="L361">        }</span>
<span class="fc" id="L362">    }</span>

    private void encodeCpuServicesParameter(ByteBuf buf, CpuServicesParameter parameter) {
        // Output the header for a CPU Services parameter.
<span class="fc" id="L366">        buf.writeByte(0x01);</span>
<span class="fc" id="L367">        buf.writeByte(0x12);</span>
        // Length of the parameter.
<span class="pc bpc" id="L369" title="1 of 2 branches missed.">        buf.writeByte((parameter instanceof CpuServicesRequestParameter) ? 0x04 : 0x08);</span>
        // Is this a request or a response?
<span class="pc bpc" id="L371" title="1 of 2 branches missed.">        buf.writeByte((parameter instanceof CpuServicesRequestParameter) ? 0x11 : 0x12);</span>
        // This is a mixture of request/response and function group .
<span class="pc bpc" id="L373" title="1 of 2 branches missed.">        byte nextByte = (byte) (((parameter instanceof CpuServicesRequestParameter) ?</span>
<span class="fc" id="L374">            (byte) 0x40 : (byte) 0x80) | parameter.getFunctionGroup().getCode());</span>
<span class="fc" id="L375">        buf.writeByte(nextByte);</span>
<span class="fc" id="L376">        buf.writeByte(parameter.getSubFunctionGroup().getCode());</span>
<span class="fc" id="L377">        buf.writeByte(parameter.getSequenceNumber());</span>

        // A response parameter has some more fields.
        // Not sure why this is implemented, we should never be sending out responses.
        /*if(parameter instanceof CpuServicesResponseParameter) {
            CpuServicesResponseParameter responseParameter = (CpuServicesResponseParameter) parameter;
            buf.writeByte(responseParameter.getDataUnitReferenceNumber());
            buf.writeByte(responseParameter.isLastDataUnit() ? 0x00 : 0x01);
            buf.writeShort(responseParameter.getError().getCode());
        }*/
<span class="fc" id="L387">    }</span>

    private void encodeS7AnyParameterItem(ByteBuf buf, S7AnyVarParameterItem s7AnyRequestItem) {
<span class="fc" id="L390">        buf.writeByte(s7AnyRequestItem.getSpecificationType().getCode());</span>
        // Length of this item (excluding spec type and length)
<span class="fc" id="L392">        buf.writeByte((byte) 0x0a);</span>
<span class="fc" id="L393">        buf.writeByte(s7AnyRequestItem.getAddressingMode().getCode());</span>
<span class="fc" id="L394">        buf.writeByte(s7AnyRequestItem.getDataType().getTypeCode());</span>
<span class="fc" id="L395">        buf.writeShort(s7AnyRequestItem.getNumElements());</span>
<span class="fc" id="L396">        buf.writeShort(s7AnyRequestItem.getDataBlockNumber());</span>
<span class="fc" id="L397">        buf.writeByte(s7AnyRequestItem.getMemoryArea().getCode());</span>
        // A S7 address is 3 bytes long. Unfortunately the byte-offset is NOT located in
        // byte 1 and byte 2 and the bit offset in byte 3. Siemens used the last 3 bits of
        // byte 3 for the bit-offset and the remaining 5 bits of byte 3 to contain the lowest
        // 5 bits of the byte-offset. The highest 5 bits of byte 1 are probably left unused
        // for future extensions.
<span class="fc" id="L403">        buf.writeShort((short) (s7AnyRequestItem.getByteOffset() &gt;&gt; 5));</span>
<span class="fc" id="L404">        buf.writeByte((byte) ((</span>
<span class="fc" id="L405">                (s7AnyRequestItem.getByteOffset() &amp; 0x1F) &lt;&lt; 3)</span>
<span class="fc" id="L406">                | (s7AnyRequestItem.getBitOffset() &amp; 0x07)));</span>
<span class="fc" id="L407">    }</span>

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Decoding
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
<span class="nc" id="L415">        decoder.channelRead(ctx, msg);</span>
<span class="nc" id="L416">        super.channelRead(ctx, msg);</span>
<span class="nc" id="L417">    }</span>

    protected void decode(ChannelHandlerContext ctx, IsoTPMessage in, List&lt;Object&gt; out) {
<span class="nc bnc" id="L420" title="All 2 branches missed.">        if (logger.isTraceEnabled()) {</span>
<span class="nc" id="L421">            logger.trace(&quot;Got Data: {}&quot;, ByteBufUtil.hexDump(in.getUserData()));</span>
        }
<span class="nc" id="L423">        ByteBuf userData = in.getUserData();</span>
<span class="nc bnc" id="L424" title="All 2 branches missed.">        if (userData.readableBytes() == 0) {</span>
<span class="nc" id="L425">            return;</span>
        }

<span class="nc bnc" id="L428" title="All 2 branches missed.">        if (userData.readByte() != S7_PROTOCOL_MAGIC_NUMBER) {</span>
<span class="nc" id="L429">            logger.warn(&quot;Expecting S7 protocol magic number.&quot;);</span>
<span class="nc bnc" id="L430" title="All 2 branches missed.">            if (logger.isDebugEnabled()) {</span>
<span class="nc" id="L431">                logger.debug(&quot;Got Data: {}&quot;, ByteBufUtil.hexDump(userData));</span>
            }
<span class="nc" id="L433">            return;</span>
        }

<span class="nc" id="L436">        MessageType messageType = MessageType.valueOf(userData.readByte());</span>
<span class="nc bnc" id="L437" title="All 2 branches missed.">        boolean isResponse = messageType == MessageType.ACK_DATA;</span>
<span class="nc" id="L438">        userData.readShort();  // Reserved (is always constant 0x0000)</span>
<span class="nc" id="L439">        short tpduReference = userData.readShort();</span>
<span class="nc" id="L440">        short headerParametersLength = userData.readShort();</span>
<span class="nc" id="L441">        short userDataLength = userData.readShort();</span>
<span class="nc" id="L442">        byte errorClass = 0;</span>
<span class="nc" id="L443">        byte errorCode = 0;</span>
<span class="nc bnc" id="L444" title="All 2 branches missed.">        if (isResponse) {</span>
<span class="nc" id="L445">            errorClass = userData.readByte();</span>
<span class="nc" id="L446">            errorCode = userData.readByte();</span>
        }

<span class="nc" id="L449">        List&lt;S7Parameter&gt; s7Parameters = new LinkedList&lt;&gt;();</span>
<span class="nc" id="L450">        int i = 0;</span>

<span class="nc bnc" id="L452" title="All 2 branches missed.">        while (i &lt; headerParametersLength) {</span>
<span class="nc" id="L453">            S7Parameter parameter = decodeParameter(userData, isResponse);</span>
<span class="nc" id="L454">            s7Parameters.add(parameter);</span>
<span class="nc bnc" id="L455" title="All 2 branches missed.">            if (parameter instanceof SetupCommunicationParameter) {</span>
<span class="nc" id="L456">                handleSetupCommunications(ctx, (SetupCommunicationParameter) parameter);</span>
            }
<span class="nc" id="L458">            i += S7SizeHelper.getParameterLength(parameter);</span>
<span class="nc" id="L459">        }</span>

<span class="nc" id="L461">        List&lt;S7Payload&gt; s7Payloads = decodePayloads(userData, isResponse, userDataLength, s7Parameters);</span>

<span class="nc" id="L463">        logger.debug(&quot;S7 Message with id {} received&quot;, tpduReference);</span>

<span class="nc bnc" id="L465" title="All 2 branches missed.">        if (isResponse) {</span>
<span class="nc" id="L466">            S7ResponseMessage responseMessage = new S7ResponseMessage(</span>
                messageType, tpduReference, s7Parameters, s7Payloads, errorClass, errorCode);

            // Remove the current response from the list of unconfirmed messages.
<span class="nc" id="L470">            DataTpdu requestTpdu = sentButUnacknowledgedTpdus.remove(tpduReference);</span>

            // Get the corresponding request message.
<span class="nc bnc" id="L473" title="All 2 branches missed.">            S7RequestMessage requestMessage = (requestTpdu != null) ? (S7RequestMessage) requestTpdu.getParent() : null;</span>

<span class="nc bnc" id="L475" title="All 2 branches missed.">            if(requestMessage != null) {</span>
                // Set this individual request to &quot;acknowledged&quot;.
<span class="nc" id="L477">                requestMessage.setAcknowledged(true);</span>

                // Give the request and response to a message processor to process the incoming message.
<span class="nc bnc" id="L480" title="All 2 branches missed.">                if(messageProcessor != null) {</span>
                    try {
<span class="nc" id="L482">                        responseMessage = messageProcessor.processResponse(requestMessage, responseMessage);</span>
<span class="nc" id="L483">                    } catch(Exception e) {</span>
<span class="nc" id="L484">                        logger.error(&quot;Error processing message&quot;, e);</span>
<span class="nc" id="L485">                        ctx.fireExceptionCaught(e);</span>
<span class="nc" id="L486">                        return;</span>
<span class="nc" id="L487">                    }</span>
                }

<span class="nc bnc" id="L490" title="All 2 branches missed.">                if(responseMessage != null) {</span>
<span class="nc" id="L491">                    out.add(responseMessage);</span>

                    // If this is a USER_DATA packet the probability is high that this is
                    // a response to the identification request, we have to handle that.
<span class="nc bnc" id="L495" title="All 2 branches missed.">                    if(responseMessage.getMessageType() == MessageType.USER_DATA) {</span>
<span class="nc bnc" id="L496" title="All 2 branches missed.">                        for (S7Payload payload : responseMessage.getPayloads()) {</span>
<span class="nc bnc" id="L497" title="All 2 branches missed.">                            if(payload instanceof CpuServicesPayload) {</span>
<span class="nc" id="L498">                                handleIdentifyRemote(ctx, (CpuServicesPayload) payload);</span>
                            }
<span class="nc" id="L500">                        }</span>
                    }
                }

                // Try to send the next message (if there is one).
<span class="nc" id="L505">                trySendingMessages(ctx);</span>
            }

<span class="nc" id="L508">        } else {</span>
            // CpuService responses are encoded as requests.
<span class="nc bnc" id="L510" title="All 2 branches missed.">            for (S7Parameter s7Parameter : s7Parameters) {</span>
                // Only if we have a response parameter, the payload is a response payload.
<span class="nc bnc" id="L512" title="All 2 branches missed.">                if(s7Parameter instanceof CpuServicesResponseParameter) {</span>
<span class="nc bnc" id="L513" title="All 2 branches missed.">                    for (S7Payload s7Payload : s7Payloads) {</span>
<span class="nc bnc" id="L514" title="All 2 branches missed.">                        if(s7Payload instanceof CpuServicesPayload) {</span>
<span class="nc" id="L515">                            CpuServicesPayload cpuServicesPayload = (CpuServicesPayload) s7Payload;</span>
<span class="nc" id="L516">                            handleIdentifyRemote(ctx, cpuServicesPayload);</span>
                        }
<span class="nc" id="L518">                    }</span>
                }
<span class="nc" id="L520">            }</span>
<span class="nc" id="L521">            out.add(new S7RequestMessage(messageType, tpduReference, s7Parameters, s7Payloads, null));</span>
        }
<span class="nc" id="L523">    }</span>

    private void handleSetupCommunications(ChannelHandlerContext ctx, SetupCommunicationParameter setupCommunicationParameter) {
<span class="nc" id="L526">        maxAmqCaller = setupCommunicationParameter.getMaxAmqCaller();</span>
<span class="nc" id="L527">        maxAmqCallee = setupCommunicationParameter.getMaxAmqCallee();</span>
<span class="nc" id="L528">        pduSize = setupCommunicationParameter.getPduLength();</span>

<span class="nc" id="L530">        logger.info(&quot;S7Connection established pdu-size {}, max-amq-caller {}, &quot; +</span>
<span class="nc" id="L531">                &quot;max-amq-callee {}&quot;, pduSize, maxAmqCaller, maxAmqCallee);</span>

        // Only if the controller type is set to &quot;ANY&quot;, then try to identify the PLC type.
<span class="nc bnc" id="L534" title="All 2 branches missed.">        if(controllerType == S7ControllerType.ANY) {</span>
            // Prepare a message to request the remote to identify itself.
<span class="nc" id="L536">            S7RequestMessage identifyRemoteMessage = new S7RequestMessage(MessageType.USER_DATA, (short) 2,</span>
<span class="nc" id="L537">                Collections.singletonList(new CpuServicesRequestParameter(</span>
                    CpuServicesParameterFunctionGroup.CPU_FUNCTIONS,
                    CpuServicesParameterSubFunctionGroup.READ_SSL, (byte) 0)),
<span class="nc" id="L540">                Collections.singletonList(new CpuServicesPayload(DataTransportErrorCode.OK, SslId.MODULE_IDENTIFICATION,</span>
                    (short) 0x0000)), null);
<span class="nc" id="L542">            ctx.channel().writeAndFlush(identifyRemoteMessage);</span>
<span class="nc" id="L543">        }</span>
        // If a concrete type was specified, then we're done here.
        else {
<span class="nc bnc" id="L546" title="All 2 branches missed.">            if(logger.isInfoEnabled()) {</span>
<span class="nc" id="L547">                logger.info(String.format(&quot;Successfully connected to S7: %s&quot;, controllerType.name()));</span>
<span class="nc" id="L548">                logger.info(String.format(&quot;- max amq caller: %s&quot;, maxAmqCaller));</span>
<span class="nc" id="L549">                logger.info(String.format(&quot;- max amq callee: %s&quot;, maxAmqCallee));</span>
<span class="nc" id="L550">                logger.info(String.format(&quot;- pdu size: %s&quot;, pduSize));</span>
            }

            // Send an event that connection setup is complete.
<span class="nc" id="L554">            ctx.channel().pipeline().fireUserEventTriggered(new S7ConnectedEvent());</span>
        }
<span class="nc" id="L556">    }</span>

    private void handleIdentifyRemote(ChannelHandlerContext ctx, CpuServicesPayload cpuServicesPayload) {
<span class="nc" id="L559">        controllerType = S7ControllerType.ANY;</span>
<span class="nc bnc" id="L560" title="All 2 branches missed.">        for (SslDataRecord sslDataRecord : cpuServicesPayload.getSslDataRecords()) {</span>
<span class="nc bnc" id="L561" title="All 2 branches missed.">            if(sslDataRecord instanceof SslModuleIdentificationDataRecord) {</span>
<span class="nc" id="L562">                SslModuleIdentificationDataRecord sslModuleIdentificationDataRecord =</span>
                    (SslModuleIdentificationDataRecord) sslDataRecord;
<span class="nc bnc" id="L564" title="All 2 branches missed.">                if(sslModuleIdentificationDataRecord.getIndex() == (short) 0x0001) {</span>
<span class="nc" id="L565">                    controllerType = lookupControllerType(sslModuleIdentificationDataRecord.getArticleNumber());</span>
                }
            }
<span class="nc" id="L568">        }</span>
<span class="nc bnc" id="L569" title="All 2 branches missed.">        if(logger.isInfoEnabled()) {</span>
<span class="nc" id="L570">            logger.info(String.format(&quot;Successfully connected to S7: %s&quot;, controllerType.name()));</span>
<span class="nc" id="L571">            logger.info(String.format(&quot;- max amq caller: %s&quot;, maxAmqCaller));</span>
<span class="nc" id="L572">            logger.info(String.format(&quot;- max amq callee: %s&quot;, maxAmqCallee));</span>
<span class="nc" id="L573">            logger.info(String.format(&quot;- pdu size: %s&quot;, pduSize));</span>
        }

        // Send an event that connection setup is complete.
<span class="nc" id="L577">        ctx.channel().pipeline().fireUserEventTriggered(new S7ConnectedEvent());</span>
<span class="nc" id="L578">    }</span>

    private List&lt;S7Payload&gt; decodePayloads(ByteBuf userData, boolean isResponse, short userDataLength, List&lt;S7Parameter&gt; s7Parameters) {
<span class="nc" id="L581">        List&lt;S7Payload&gt; s7Payloads = new LinkedList&lt;&gt;();</span>
<span class="nc bnc" id="L582" title="All 2 branches missed.">        for (S7Parameter s7Parameter : s7Parameters) {</span>
<span class="nc bnc" id="L583" title="All 2 branches missed.">            if(s7Parameter instanceof VarParameter) {</span>
<span class="nc" id="L584">                VarParameter readWriteVarParameter = (VarParameter) s7Parameter;</span>
<span class="nc" id="L585">                VarPayload varPayload = decodeVarPayload(userData, isResponse, userDataLength, readWriteVarParameter);</span>
<span class="nc" id="L586">                s7Payloads.add(varPayload);</span>
<span class="nc bnc" id="L587" title="All 2 branches missed.">            } else if(s7Parameter instanceof CpuServicesParameter) {</span>
<span class="nc" id="L588">                CpuServicesPayload cpuServicesPayload = decodeCpuServicesPayload(userData);</span>
<span class="nc" id="L589">                s7Payloads.add(cpuServicesPayload);</span>
            }
<span class="nc" id="L591">        }</span>
<span class="nc" id="L592">        return s7Payloads;</span>
    }

    private VarPayload decodeVarPayload(ByteBuf userData, boolean isResponse, short userDataLength,
                                        VarParameter readWriteVarParameter) {
<span class="nc" id="L597">        List&lt;VarPayloadItem&gt; payloadItems = new LinkedList&lt;&gt;();</span>

        // Just keep on reading payloads until the provided length is read.
<span class="nc" id="L600">        int i = 0;</span>
<span class="nc bnc" id="L601" title="All 2 branches missed.">        while (i &lt; userDataLength) {</span>
<span class="nc" id="L602">            DataTransportErrorCode dataTransportErrorCode = DataTransportErrorCode.valueOf(userData.readByte());</span>
            // This is a response to a WRITE_VAR request (It only contains the return code for every sent item.
<span class="nc bnc" id="L604" title="All 4 branches missed.">            if ((readWriteVarParameter.getType() == ParameterType.WRITE_VAR) &amp;&amp; isResponse) {</span>
                // Initialize a rudimentary payload (This is updated in the Plc4XS7Protocol class
<span class="nc" id="L606">                VarPayloadItem payload = new VarPayloadItem(dataTransportErrorCode, null, null);</span>
<span class="nc" id="L607">                payloadItems.add(payload);</span>
<span class="nc" id="L608">                i += 1;</span>
<span class="nc" id="L609">            }</span>
            // This is a response to a READ_VAR request.
<span class="nc bnc" id="L611" title="All 4 branches missed.">            else if ((readWriteVarParameter.getType() == ParameterType.READ_VAR) &amp;&amp; isResponse) {</span>
<span class="nc" id="L612">                DataTransportSize dataTransportSize = DataTransportSize.valueOf(userData.readByte());</span>
<span class="nc bnc" id="L613" title="All 2 branches missed.">                short length = dataTransportSize.isSizeInBits() ?</span>
<span class="nc" id="L614">                    (short) Math.ceil(userData.readShort() / 8.0) : userData.readShort();</span>
<span class="nc" id="L615">                byte[] data = new byte[length];</span>
<span class="nc" id="L616">                userData.readBytes(data);</span>
                // Initialize a rudimentary payload (This is updated in the Plc4XS7Protocol class
<span class="nc" id="L618">                VarPayloadItem payload = new VarPayloadItem(dataTransportErrorCode, dataTransportSize, data);</span>
<span class="nc" id="L619">                payloadItems.add(payload);</span>
<span class="nc" id="L620">                i += S7SizeHelper.getPayloadLength(payload);</span>

                // It seems that one-byte payloads require a fill byte, but only if it's not the last item.
<span class="nc bnc" id="L623" title="All 4 branches missed.">                if((length == 1) &amp;&amp; (userData.readableBytes() &gt; 0)) {</span>
<span class="nc" id="L624">                    userData.readByte();</span>
<span class="nc" id="L625">                    i++;</span>
                }
            }
<span class="nc" id="L628">        }</span>

<span class="nc" id="L630">        return new VarPayload(readWriteVarParameter.getType(), payloadItems);</span>
    }

    private CpuServicesPayload decodeCpuServicesPayload(ByteBuf userData) {
<span class="nc" id="L634">        DataTransportErrorCode returnCode = DataTransportErrorCode.valueOf(userData.readByte());</span>
<span class="nc" id="L635">        DataTransportSize dataTransportSize = DataTransportSize.valueOf(userData.readByte());</span>
<span class="nc bnc" id="L636" title="All 2 branches missed.">        if(dataTransportSize != DataTransportSize.OCTET_STRING) {</span>
            // TODO: Output an error.
        }
<span class="nc" id="L639">        short length = userData.readShort();</span>
<span class="nc" id="L640">        SslId sslId = SslId.valueOf(userData.readShort());</span>
<span class="nc" id="L641">        short sslIndex = userData.readShort();</span>
        // If the length is 4 there is no `partial list length in bytes` and `partial list count` parameters.
<span class="nc bnc" id="L643" title="All 2 branches missed.">        if(length == 4) {</span>
<span class="nc" id="L644">            return new CpuServicesPayload(returnCode, sslId, sslIndex);</span>
        }
        // If the length is not 4, then it has to be at least 8.
<span class="nc bnc" id="L647" title="All 2 branches missed.">        else if(length &gt;= 8) {</span>
            // TODO: We should probably ensure we don't read more than this.
            // Skip the partial list length in words.
<span class="nc" id="L650">            userData.skipBytes(2);</span>
<span class="nc" id="L651">            short partialListCount = userData.readShort();</span>
<span class="nc" id="L652">            List&lt;SslDataRecord&gt; sslDataRecords = new LinkedList&lt;&gt;();</span>
<span class="nc bnc" id="L653" title="All 2 branches missed.">            for(int i = 0; i &lt; partialListCount; i++) {</span>
<span class="nc" id="L654">                short index = userData.readShort();</span>
<span class="nc" id="L655">                byte[] articleNumberBytes = new byte[20];</span>
<span class="nc" id="L656">                userData.readBytes(articleNumberBytes);</span>
<span class="nc" id="L657">                String articleNumber = new String(articleNumberBytes, StandardCharsets.UTF_8).trim();</span>
<span class="nc" id="L658">                short bgType = userData.readShort();</span>
<span class="nc" id="L659">                short moduleOrOsVersion = userData.readShort();</span>
<span class="nc" id="L660">                short pgDescriptionFileVersion = userData.readShort();</span>
<span class="nc" id="L661">                sslDataRecords.add(new SslModuleIdentificationDataRecord(</span>
                    index, articleNumber, bgType, moduleOrOsVersion, pgDescriptionFileVersion));
            }
<span class="nc" id="L664">            return new CpuServicesPayload(returnCode, sslId, sslIndex, sslDataRecords);</span>
        }
        // In all other cases, it's probably an error.
        else {
            // TODO: Output an error.
        }
<span class="nc" id="L670">        return null;</span>
    }

    private S7Parameter decodeParameter(ByteBuf in, boolean isResponse) {
<span class="nc" id="L674">        ParameterType parameterType = ParameterType.valueOf(in.readByte());</span>
<span class="nc bnc" id="L675" title="All 2 branches missed.">        if (parameterType == null) {</span>
<span class="nc" id="L676">            logger.error(&quot;Could not find parameter type&quot;);</span>
<span class="nc" id="L677">            return null;</span>
        }
<span class="nc bnc" id="L679" title="All 4 branches missed.">        switch (parameterType) {</span>
            case CPU_SERVICES:
<span class="nc" id="L681">                return decodeCpuServicesParameter(in);</span>
            case READ_VAR:
            case WRITE_VAR:
                List&lt;VarParameterItem&gt; varParameterItems;
<span class="nc" id="L685">                byte numItems = in.readByte();</span>
<span class="nc bnc" id="L686" title="All 2 branches missed.">                if (!isResponse) {</span>
<span class="nc" id="L687">                    varParameterItems = decodeReadWriteVarParameter(in, numItems);</span>
                } else {
<span class="nc" id="L689">                    varParameterItems = Collections.singletonList(</span>
                        new S7AnyVarParameterItem(null, null, null, numItems, (short) 0, (short) 0, (byte) 0));
                }
<span class="nc" id="L692">                return new VarParameter(parameterType, varParameterItems);</span>
            case SETUP_COMMUNICATION:
                // Reserved (is always constant 0x00)
<span class="nc" id="L695">                in.readByte();</span>
<span class="nc" id="L696">                short callingMaxAmq = in.readShort();</span>
<span class="nc" id="L697">                short calledMaxAmq = in.readShort();</span>
<span class="nc" id="L698">                short pduLength = in.readShort();</span>
<span class="nc" id="L699">                return new SetupCommunicationParameter(callingMaxAmq, calledMaxAmq, pduLength);</span>
            default:
<span class="nc bnc" id="L701" title="All 2 branches missed.">                if (logger.isErrorEnabled()) {</span>
<span class="nc" id="L702">                    logger.error(&quot;Unimplemented parameter type: {}&quot;, parameterType.name());</span>
                }
        }
<span class="nc" id="L705">        return null;</span>
    }

    private CpuServicesParameter decodeCpuServicesParameter(ByteBuf in) {
<span class="nc bnc" id="L709" title="All 2 branches missed.">        if(in.readShort() != 0x0112) {</span>
<span class="nc bnc" id="L710" title="All 2 branches missed.">            if (logger.isErrorEnabled()) {</span>
<span class="nc" id="L711">                logger.error(&quot;Expecting 0x0112 for CPU_SERVICES parameter&quot;);</span>
            }
<span class="nc" id="L713">            return null;</span>
        }
<span class="nc" id="L715">        byte parameterLength = in.readByte();</span>
<span class="nc bnc" id="L716" title="All 4 branches missed.">        if((parameterLength != 4) &amp;&amp; (parameterLength != 8)) {</span>
<span class="nc bnc" id="L717" title="All 2 branches missed.">            if (logger.isErrorEnabled()) {</span>
<span class="nc" id="L718">                logger.error(&quot;Parameter length should be 4 or 8, but was {}&quot;, parameterLength);</span>
            }
<span class="nc" id="L720">            return null;</span>
        }
        // Skipping this as it sort of contains redundant information.
<span class="nc" id="L723">        in.readByte();</span>
<span class="nc" id="L724">        byte typeAndFunctionGroup = in.readByte();</span>
        // If bit 7 is set, it's a request (if bit 8 is set it's a response).
<span class="nc bnc" id="L726" title="All 2 branches missed.">        boolean requestParameter = (typeAndFunctionGroup &amp; 0x64) != 0;</span>
        // The last 4 bits contain the function group value.
<span class="nc" id="L728">        typeAndFunctionGroup = (byte) (typeAndFunctionGroup &amp; 0xF);</span>
<span class="nc" id="L729">        CpuServicesParameterFunctionGroup functionGroup =</span>
<span class="nc" id="L730">            CpuServicesParameterFunctionGroup.valueOf(typeAndFunctionGroup);</span>
<span class="nc" id="L731">        CpuServicesParameterSubFunctionGroup subFunctionGroup =</span>
<span class="nc" id="L732">            CpuServicesParameterSubFunctionGroup.valueOf(in.readByte());</span>
<span class="nc" id="L733">        byte sequenceNumber = in.readByte();</span>
<span class="nc bnc" id="L734" title="All 2 branches missed.">        if(!requestParameter) {</span>
<span class="nc" id="L735">            return new CpuServicesRequestParameter(functionGroup, subFunctionGroup, sequenceNumber);</span>
        } else {
<span class="nc" id="L737">            byte dataUnitReferenceNumber = in.readByte();</span>
<span class="nc bnc" id="L738" title="All 2 branches missed.">            boolean lastDataUnit = in.readByte() == 0x00;</span>
<span class="nc" id="L739">            ParameterError error = ParameterError.valueOf(in.readShort());</span>
<span class="nc" id="L740">            return new CpuServicesResponseParameter(functionGroup, subFunctionGroup, sequenceNumber,</span>
                dataUnitReferenceNumber, lastDataUnit, error);
        }
    }

    private List&lt;VarParameterItem&gt; decodeReadWriteVarParameter(ByteBuf in, byte numItems) {
<span class="nc" id="L746">        List&lt;VarParameterItem&gt; items = new LinkedList&lt;&gt;();</span>
<span class="nc bnc" id="L747" title="All 2 branches missed.">        for (int i = 0; i &lt; numItems; i++) {</span>
<span class="nc" id="L748">            SpecificationType specificationType = SpecificationType.valueOf(in.readByte());</span>
            // Length of the rest of this item.
<span class="nc" id="L750">            byte itemLength = in.readByte();</span>
<span class="nc bnc" id="L751" title="All 2 branches missed.">            if (itemLength != 0x0a) {</span>
<span class="nc" id="L752">                logger.warn(&quot;Expecting a length of 10 here.&quot;);</span>
<span class="nc" id="L753">                return items;</span>
            }
<span class="nc" id="L755">            VariableAddressingMode variableAddressingMode = VariableAddressingMode.valueOf(in.readByte());</span>
<span class="nc bnc" id="L756" title="All 2 branches missed.">            if (variableAddressingMode == VariableAddressingMode.S7ANY) {</span>
<span class="nc" id="L757">                TransportSize dataType = TransportSize.valueOf(in.readByte());</span>
<span class="nc" id="L758">                short length = in.readShort();</span>
<span class="nc" id="L759">                short dbNumber = in.readShort();</span>
<span class="nc" id="L760">                MemoryArea memoryArea = MemoryArea.valueOf(in.readByte());</span>
<span class="nc" id="L761">                short byteAddress = (short) (in.readShort() &lt;&lt; 5);</span>
<span class="nc" id="L762">                byte tmp = in.readByte();</span>
                // Only the least 3 bits are the bit address, the
<span class="nc" id="L764">                byte bitAddress = (byte) (tmp &amp; 0x07);</span>
                // Bits 4-8 belong to the byte address
<span class="nc" id="L766">                byteAddress = (short) (byteAddress | (tmp &gt;&gt; 3));</span>
<span class="nc" id="L767">                S7AnyVarParameterItem item = new S7AnyVarParameterItem(</span>
                        specificationType, memoryArea, dataType,
                        length, dbNumber, byteAddress, bitAddress);
<span class="nc" id="L770">                items.add(item);</span>
<span class="nc" id="L771">            } else {</span>
<span class="nc" id="L772">                logger.error(&quot;Error parsing item type&quot;);</span>
<span class="nc" id="L773">                return items;</span>
            }
        }

<span class="nc" id="L777">        return items;</span>
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Helpers
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


    private synchronized void trySendingMessages(ChannelHandlerContext ctx) {
<span class="pc bpc" id="L786" title="1 of 2 branches missed.">        while(sentButUnacknowledgedTpdus.size() &lt; maxAmqCaller) {</span>
            // Get the TPDU that is up next in the queue.
<span class="fc" id="L788">            DataTpdu curTpdu = (DataTpdu) queue.current();</span>

<span class="pc bpc" id="L790" title="1 of 2 branches missed.">            if (curTpdu != null) {</span>
                // Send the TPDU.
                try {
<span class="fc" id="L793">                    ChannelFuture channelFuture = queue.removeAndWrite();</span>
<span class="fc" id="L794">                    ctx.flush();</span>
<span class="pc bpc" id="L795" title="1 of 2 branches missed.">                    if (channelFuture == null) {</span>
<span class="nc" id="L796">                        break;</span>
                    }
<span class="nc" id="L798">                } catch (Exception e) {</span>
<span class="nc" id="L799">                    logger.error(&quot;Error sending more queues messages&quot;, e);</span>
<span class="nc" id="L800">                    ctx.fireExceptionCaught(e);</span>
<span class="fc" id="L801">                }</span>

<span class="pc bpc" id="L803" title="1 of 2 branches missed.">                if(curTpdu.getParent() != null) {</span>
                    // Add it to the list of sentButUnacknowledgedTpdus.
                    // (It seems that the S7 drops the value of the COTP reference id, so we have to use the S7 one)
<span class="fc" id="L806">                    S7RequestMessage s7RequestMessage = (S7RequestMessage) curTpdu.getParent();</span>
<span class="fc" id="L807">                    sentButUnacknowledgedTpdus.put(s7RequestMessage.getTpduReference(), curTpdu);</span>

<span class="fc" id="L809">                    logger.debug(&quot;S7 Message with id {} sent&quot;, s7RequestMessage.getTpduReference());</span>
<span class="fc" id="L810">                }</span>
                // TODO: Perhaps remove this.
                break;
            } else {
                break;
            }
        }
<span class="fc" id="L817">        ctx.flush();</span>
<span class="fc" id="L818">    }</span>

    private S7ControllerType lookupControllerType(String articleNumber) {
<span class="nc bnc" id="L821" title="All 2 branches missed.">        if(!articleNumber.startsWith(&quot;6ES7 &quot;)) {</span>
<span class="nc" id="L822">            return S7ControllerType.ANY;</span>
        }

<span class="nc" id="L825">        String model = articleNumber.substring(articleNumber.indexOf(' ') + 1, articleNumber.indexOf(' ') + 2);</span>
<span class="nc bnc" id="L826" title="All 5 branches missed.">        switch (model) {</span>
            case &quot;2&quot;:
<span class="nc" id="L828">                return S7ControllerType.S7_1200;</span>
            case &quot;5&quot;:
<span class="nc" id="L830">                return S7ControllerType.S7_1500;</span>
            case &quot;3&quot;:
<span class="nc" id="L832">                return S7ControllerType.S7_300;</span>
            case &quot;4&quot;:
<span class="nc" id="L834">                return S7ControllerType.S7_400;</span>
            default:
<span class="nc bnc" id="L836" title="All 2 branches missed.">                if(logger.isInfoEnabled()) {</span>
<span class="nc" id="L837">                    logger.info(String.format(&quot;Looking up unknown article number %s&quot;, articleNumber));</span>
                }
<span class="nc" id="L839">                return S7ControllerType.ANY;</span>
        }
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>