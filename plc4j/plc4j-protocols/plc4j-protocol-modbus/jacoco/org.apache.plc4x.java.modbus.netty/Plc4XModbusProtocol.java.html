<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Plc4XModbusProtocol.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">PLC4J: Protocol: Modbus</a> &gt; <a href="index.source.html" class="el_package">org.apache.plc4x.java.modbus.netty</a> &gt; <span class="el_source">Plc4XModbusProtocol.java</span></div><h1>Plc4XModbusProtocol.java</h1><pre class="source lang-java linenums">/*
 Licensed to the Apache Software Foundation (ASF) under one
 or more contributor license agreements.  See the NOTICE file
 distributed with this work for additional information
 regarding copyright ownership.  The ASF licenses this file
 to you under the Apache License, Version 2.0 (the
 &quot;License&quot;); you may not use this file except in compliance
 with the License.  You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing,
 software distributed under the License is distributed on an
 &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 KIND, either express or implied.  See the License for the
 specific language governing permissions and limitations
 under the License.
 */
package org.apache.plc4x.java.modbus.netty;

import com.digitalpetri.modbus.ModbusPdu;
import com.digitalpetri.modbus.codec.ModbusTcpPayload;
import com.digitalpetri.modbus.requests.*;
import com.digitalpetri.modbus.responses.*;
import io.netty.buffer.ByteBuf;
import io.netty.buffer.Unpooled;
import io.netty.channel.ChannelHandlerContext;
import io.netty.handler.codec.MessageToMessageCodec;
import org.apache.commons.lang3.ArrayUtils;
import org.apache.commons.lang3.tuple.ImmutablePair;
import org.apache.commons.lang3.tuple.Pair;
import org.apache.plc4x.java.api.exceptions.PlcException;
import org.apache.plc4x.java.api.exceptions.PlcNotImplementedException;
import org.apache.plc4x.java.api.exceptions.PlcProtocolException;
import org.apache.plc4x.java.api.exceptions.PlcUnsupportedDataTypeException;
import org.apache.plc4x.java.api.messages.PlcReadRequest;
import org.apache.plc4x.java.api.messages.PlcRequest;
import org.apache.plc4x.java.api.messages.PlcWriteRequest;
import org.apache.plc4x.java.api.types.PlcResponseCode;
import org.apache.plc4x.java.base.messages.*;
import org.apache.plc4x.java.base.messages.items.BaseDefaultFieldItem;
import org.apache.plc4x.java.base.messages.items.DefaultBooleanFieldItem;
import org.apache.plc4x.java.modbus.messages.items.DefaultModbusByteArrayFieldItem;
import org.apache.plc4x.java.modbus.model.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.math.BigInteger;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.atomic.AtomicInteger;


<span class="fc" id="L55">public class Plc4XModbusProtocol extends MessageToMessageCodec&lt;ModbusTcpPayload, PlcRequestContainer&lt;InternalPlcRequest, InternalPlcResponse&gt;&gt; {</span>

<span class="fc" id="L57">    private static final Logger LOGGER = LoggerFactory.getLogger(Plc4XModbusProtocol.class);</span>

<span class="fc" id="L59">    public final AtomicInteger transactionId = new AtomicInteger();</span>

<span class="fc" id="L61">    private final ConcurrentMap&lt;Short, PlcRequestContainer&lt;InternalPlcRequest, InternalPlcResponse&gt;&gt; requestsMap = new ConcurrentHashMap&lt;&gt;();</span>

    @Override
    protected void encode(ChannelHandlerContext ctx, PlcRequestContainer&lt;InternalPlcRequest, InternalPlcResponse&gt; msg, List&lt;Object&gt; out) throws Exception {
<span class="fc" id="L65">        LOGGER.trace(&quot;(&lt;--OUT): {}, {}, {}&quot;, ctx, msg, out);</span>
        // Reset transactionId on overflow
<span class="fc" id="L67">        transactionId.compareAndSet(Short.MAX_VALUE + 1, 0);</span>
<span class="fc" id="L68">        PlcRequest request = msg.getRequest();</span>
<span class="fc bfc" id="L69" title="All 2 branches covered.">        if (request instanceof PlcReadRequest) {</span>
<span class="fc" id="L70">            encodeReadRequest(msg, out);</span>
<span class="pc bpc" id="L71" title="1 of 2 branches missed.">        } else if (request instanceof PlcWriteRequest) {</span>
<span class="fc" id="L72">            encodeWriteRequest(msg, out);</span>
        }
<span class="fc" id="L74">    }</span>

    private void encodeWriteRequest(PlcRequestContainer&lt;InternalPlcRequest, InternalPlcResponse&gt; msg, List&lt;Object&gt; out) throws PlcException {
<span class="fc" id="L77">        InternalPlcWriteRequest request = (InternalPlcWriteRequest) msg.getRequest();</span>

        // TODO: support multiple requests
<span class="pc bpc" id="L80" title="1 of 2 branches missed.">        if (request.getFieldNames().size() != 1) {</span>
<span class="nc" id="L81">            throw new PlcNotImplementedException(&quot;Only single message supported for now&quot;);</span>
        }
        // TODO: check if we can map like this. Implication is that we can only work with int, short, byte and boolean
        // TODO: for higher data types float, double etc we might need to split the bytes into chunks
<span class="fc" id="L85">        String fieldName = request.getFieldNames().iterator().next();</span>
<span class="fc" id="L86">        int quantity = request.getNumberOfValues(fieldName);</span>
<span class="fc" id="L87">        ModbusField field = (ModbusField) request.getField(fieldName);</span>
<span class="fc bfc" id="L88" title="All 2 branches covered.">        if (quantity != field.getQuantity()) {</span>
<span class="fc" id="L89">            LOGGER.warn(&quot;Supplied number of values [{}] don't match t the addressed quantity of [{}]&quot;, field.getQuantity(), quantity);</span>
        }

<span class="fc" id="L92">        short unitId = 0;</span>

        /*
         * It seems that in Modbus, there are only two types of resources, that can be accessed:
         * - Register: 2 byte value
         * - Coil: 1 bit value
         *
         * Registers:
         * When writing a bit, byte or char (a one byte or less data types) into a register the value is filled up to
         * fit the 2 bytes.
         * When writing a data type that has more than 2 bytes, subsequent registers are written to automatically.
         *
         * Coils:
         * When transferring data from/to a coil, 8 coil values can be transferred in a single byte.
         * Naturally a coil is a boolean data type, however, similar to the registers bigger data types can be
         * transported, by setting multiple subsequent coils: 32bit int -&gt; 32 coils
         *
         * In all cases where we are accessing more than the natural size of the datatype, we have to keep this in mind
         * when addressing them. So if reading 2 32bit integers, this is split up into four registers. So for the second
         * int we have to increment the address accordingly.
         */
        ModbusPdu modbusRequest;
<span class="fc bfc" id="L114" title="All 2 branches covered.">        if (field instanceof RegisterModbusField) {</span>
<span class="fc" id="L115">            RegisterModbusField registerModbusField = (RegisterModbusField) field;</span>
<span class="fc bfc" id="L116" title="All 2 branches covered.">            if (quantity &gt; 1) {</span>
<span class="fc" id="L117">                byte[] bytesToWrite = produceRegisterValue(Arrays.asList(request.getFieldItem(fieldName).getValues()));</span>
                // A register is a 16 bit (2 byte) value ... so every value needs 2 byte.
<span class="fc" id="L119">                int requiredLength = 2 * quantity;</span>
<span class="pc bpc" id="L120" title="1 of 2 branches missed.">                if (bytesToWrite.length != requiredLength) {</span>
<span class="nc" id="L121">                    throw new PlcProtocolException(&quot;Invalid register values created. Should be at least quantity * 2 = N bytes. Was &quot; + bytesToWrite.length + &quot;, expected &quot; + requiredLength);</span>
                }
<span class="fc" id="L123">                modbusRequest = new WriteMultipleRegistersRequest(registerModbusField.getAddress(), quantity, bytesToWrite);</span>
<span class="fc" id="L124">            } else {</span>
<span class="fc" id="L125">                byte[] register = produceRegisterValue(Arrays.asList(request.getFieldItem(fieldName).getValues()));</span>
<span class="pc bpc" id="L126" title="2 of 4 branches missed.">                if ((register == null) || (register.length != 2)) {</span>
<span class="nc bnc" id="L127" title="All 2 branches missed.">                    throw new PlcProtocolException(&quot;Invalid register values created. Should be 2 bytes. Was &quot; +</span>
                        ((register != null) ? register.length : 0));
                }
                // Reconvert the two bytes back to an int.
<span class="fc" id="L131">                int intToWrite = register[0] &lt;&lt; 8 | register[1] &amp; 0xff;</span>
<span class="fc" id="L132">                modbusRequest = new WriteSingleRegisterRequest(registerModbusField.getAddress(), intToWrite);</span>
            }
<span class="fc bfc" id="L134" title="All 2 branches covered.">        } else if (field instanceof CoilModbusField) {</span>
<span class="fc" id="L135">            CoilModbusField coilModbusField = (CoilModbusField) field;</span>
<span class="fc bfc" id="L136" title="All 2 branches covered.">            if (quantity &gt; 1) {</span>
<span class="fc" id="L137">                byte[] bytesToWrite = produceCoilValues(Arrays.asList(request.getFieldItem(fieldName).getValues()));</span>
                // As each coil value represents a bit, the number of bytes needed
                // equals &quot;ceil(quantity/8)&quot; (a 3 bit shift is a division by 8 ... the +1 is the &quot;ceil&quot;)
<span class="fc" id="L140">                int requiredLength = (quantity &gt;&gt; 3) + 1;</span>
<span class="pc bpc" id="L141" title="1 of 2 branches missed.">                if (bytesToWrite.length != requiredLength) {</span>
<span class="nc" id="L142">                    throw new PlcProtocolException(</span>
                        &quot;Invalid coil values created. Should be big enough to transport N bits. Was &quot; +
                            bytesToWrite.length + &quot;, expected &quot; + requiredLength);
                }
<span class="fc" id="L146">                modbusRequest = new WriteMultipleCoilsRequest(coilModbusField.getAddress(), quantity, bytesToWrite);</span>
<span class="fc" id="L147">            } else {</span>
<span class="fc" id="L148">                boolean booleanToWrite = produceCoilValue(Arrays.asList(request.getFieldItem(fieldName).getValues()));</span>
<span class="fc" id="L149">                modbusRequest = new WriteSingleCoilRequest(coilModbusField.getAddress(), booleanToWrite);</span>
            }
<span class="pc bpc" id="L151" title="1 of 2 branches missed.">        } else if (field instanceof MaskWriteRegisterModbusField) {</span>
<span class="fc" id="L152">            MaskWriteRegisterModbusField maskWriteRegisterModbusField = (MaskWriteRegisterModbusField) field;</span>
<span class="pc bpc" id="L153" title="1 of 2 branches missed.">            if (quantity &gt; 1) {</span>
<span class="nc" id="L154">                throw new PlcProtocolException(&quot;Mask write request can only write one value&quot;);</span>
            } else {
                // TODO: this should be better part of the payload not the addressing.
<span class="fc" id="L157">                int andMask = maskWriteRegisterModbusField.getAndMask();</span>
<span class="fc" id="L158">                int orMask = maskWriteRegisterModbusField.getOrMask();</span>
<span class="fc" id="L159">                modbusRequest = new MaskWriteRegisterRequest(maskWriteRegisterModbusField.getAddress(), andMask, orMask);</span>
            }
<span class="fc" id="L161">        } else {</span>
<span class="nc" id="L162">            throw new PlcProtocolException(&quot;Unsupported field type &quot; + field.getClass() + &quot; for a write request.&quot;);</span>
        }
<span class="fc" id="L164">        short transactionId = (short) this.transactionId.getAndIncrement();</span>
<span class="fc" id="L165">        requestsMap.put(transactionId, msg);</span>
<span class="fc" id="L166">        out.add(new ModbusTcpPayload(transactionId, unitId, modbusRequest));</span>
<span class="fc" id="L167">    }</span>

    private void encodeReadRequest(PlcRequestContainer&lt;InternalPlcRequest, InternalPlcResponse&gt; msg, List&lt;Object&gt; out) throws PlcException {
<span class="fc" id="L170">        PlcReadRequest request = (PlcReadRequest) msg.getRequest();</span>
        // TODO: support multiple requests
<span class="pc bpc" id="L172" title="1 of 2 branches missed.">        if (request.getFieldNames().size() != 1) {</span>
<span class="nc" id="L173">            throw new PlcNotImplementedException(&quot;Only single message supported for now&quot;);</span>
        }
        // TODO: check if we can map like this. Implication is that we can only work with int, short, byte and boolean
        // TODO: for higher data types float, double etc we might need to split the bytes into chunks
<span class="fc" id="L177">        String fieldName = request.getFieldNames().iterator().next();</span>

<span class="fc" id="L179">        ModbusField field = (ModbusField) request.getField(fieldName);</span>
<span class="fc" id="L180">        int quantity = field.getQuantity();</span>
        // TODO: the unit the should be used for multiple Requests
<span class="fc" id="L182">        short unitId = 0;</span>

        ModbusPdu modbusRequest;
<span class="fc bfc" id="L185" title="All 2 branches covered.">        if (field instanceof CoilModbusField) {</span>
<span class="fc" id="L186">            CoilModbusField coilModbusField = (CoilModbusField) field;</span>
<span class="fc" id="L187">            modbusRequest = new ReadCoilsRequest(coilModbusField.getAddress(), quantity);</span>
<span class="pc bpc" id="L188" title="1 of 2 branches missed.">        } else if (field instanceof RegisterModbusField) {</span>
<span class="nc" id="L189">            RegisterModbusField registerModbusField = (RegisterModbusField) field;</span>
<span class="nc" id="L190">            modbusRequest = new ReadHoldingRegistersRequest(registerModbusField.getAddress(), quantity);</span>
<span class="pc bfc" id="L191" title="All 2 branches covered.">        } else if (field instanceof ReadDiscreteInputsModbusField) {</span>
<span class="fc" id="L192">            ReadDiscreteInputsModbusField readDiscreteInputsModbusField = (ReadDiscreteInputsModbusField) field;</span>
<span class="fc" id="L193">            modbusRequest = new ReadDiscreteInputsRequest(readDiscreteInputsModbusField.getAddress(), quantity);</span>
<span class="fc bfc" id="L194" title="All 2 branches covered.">        } else if (field instanceof ReadHoldingRegistersModbusField) {</span>
<span class="fc" id="L195">            ReadHoldingRegistersModbusField readHoldingRegistersModbusField = (ReadHoldingRegistersModbusField) field;</span>
<span class="fc" id="L196">            modbusRequest = new ReadHoldingRegistersRequest(readHoldingRegistersModbusField.getAddress(), quantity);</span>
<span class="pc bpc" id="L197" title="1 of 2 branches missed.">        } else if (field instanceof ReadInputRegistersModbusField) {</span>
<span class="fc" id="L198">            ReadInputRegistersModbusField readInputRegistersModbusField = (ReadInputRegistersModbusField) field;</span>
<span class="fc" id="L199">            modbusRequest = new ReadInputRegistersRequest(readInputRegistersModbusField.getAddress(), quantity);</span>
<span class="fc" id="L200">        } else {</span>
<span class="nc" id="L201">            throw new PlcProtocolException(&quot;Unsupported field type &quot; + field.getClass() + &quot; for a read request.&quot;);</span>
        }
<span class="fc" id="L203">        short transactionId = (short) this.transactionId.getAndIncrement();</span>
<span class="fc" id="L204">        requestsMap.put(transactionId, msg);</span>
<span class="fc" id="L205">        out.add(new ModbusTcpPayload(transactionId, unitId, modbusRequest));</span>
<span class="fc" id="L206">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    @Override
    protected void decode(ChannelHandlerContext ctx, ModbusTcpPayload msg, List&lt;Object&gt; out) throws Exception {
<span class="fc" id="L211">        LOGGER.trace(&quot;(--&gt;IN): {}, {}, {}&quot;, ctx, msg, out);</span>
<span class="fc" id="L212">        LOGGER.debug(&quot;{}: transactionId: {}, unitId: {}, modbusPdu:{}&quot;, msg, msg.getTransactionId(), msg.getUnitId(), msg.getModbusPdu());</span>
        // TODO: implement me
<span class="fc" id="L214">        short transactionId = msg.getTransactionId();</span>
<span class="fc" id="L215">        PlcRequestContainer&lt;InternalPlcRequest, InternalPlcResponse&gt; plcRequestContainer = requestsMap.get(transactionId);</span>
<span class="pc bpc" id="L216" title="1 of 2 branches missed.">        if (plcRequestContainer == null) {</span>
<span class="nc" id="L217">            throw new PlcProtocolException(&quot;Unrelated payload received. [transactionId: &quot; + msg.getTransactionId() + &quot;, unitId: &quot; + msg.getUnitId() + &quot;, modbusPdu: &quot; + msg.getModbusPdu() + &quot;]&quot;);</span>
        }

        // TODO: only single Item supported for now
<span class="fc" id="L221">        InternalPlcFieldRequest request = (InternalPlcFieldRequest) plcRequestContainer.getRequest();</span>
        // TODO: support multiple requests (Shouldn't be needed as the request wouldn't have been sent)
<span class="pc bpc" id="L223" title="1 of 2 branches missed.">        if (request.getFieldNames().size() != 1) {</span>
<span class="nc" id="L224">            throw new PlcNotImplementedException(&quot;Only single message supported for now&quot;);</span>
        }
<span class="fc" id="L226">        String fieldName = request.getFieldNames().iterator().next();</span>
<span class="fc" id="L227">        ModbusField field = (ModbusField) request.getField(fieldName);</span>

<span class="fc" id="L229">        ModbusPdu modbusPdu = msg.getModbusPdu();</span>
        //short unitId = msg.getUnitId();

<span class="fc bfc" id="L232" title="All 2 branches covered.">        if (modbusPdu instanceof WriteMultipleCoilsResponse) {</span>
            // TODO: finish implementation
<span class="fc" id="L234">            WriteMultipleCoilsResponse writeMultipleCoilsResponse = (WriteMultipleCoilsResponse) modbusPdu;</span>
<span class="fc" id="L235">            LOGGER.debug(&quot;{}: address:{}, quantity:{}&quot;, writeMultipleCoilsResponse, writeMultipleCoilsResponse.getAddress(), writeMultipleCoilsResponse.getQuantity());</span>
<span class="fc" id="L236">            Map&lt;String, PlcResponseCode&gt; responseValues = new HashMap&lt;&gt;();</span>
<span class="fc" id="L237">            responseValues.put(fieldName, PlcResponseCode.OK);</span>
<span class="fc" id="L238">            plcRequestContainer.getResponseFuture().complete(new DefaultPlcWriteResponse((InternalPlcWriteRequest) request, responseValues));</span>
<span class="fc bfc" id="L239" title="All 2 branches covered.">        } else if (modbusPdu instanceof WriteMultipleRegistersResponse) {</span>
            // TODO: finish implementation
<span class="fc" id="L241">            WriteMultipleRegistersResponse writeMultipleRegistersResponse = (WriteMultipleRegistersResponse) modbusPdu;</span>
<span class="fc" id="L242">            LOGGER.debug(&quot;{}: address:{}, quantity:{}&quot;, writeMultipleRegistersResponse, writeMultipleRegistersResponse.getAddress(), writeMultipleRegistersResponse.getQuantity());</span>
<span class="fc" id="L243">            Map&lt;String, PlcResponseCode&gt; responseValues = new HashMap&lt;&gt;();</span>
<span class="fc" id="L244">            responseValues.put(fieldName, PlcResponseCode.OK);</span>
<span class="fc" id="L245">            plcRequestContainer.getResponseFuture().complete(new DefaultPlcWriteResponse((InternalPlcWriteRequest) request, responseValues));</span>
<span class="fc bfc" id="L246" title="All 2 branches covered.">        } else if (modbusPdu instanceof WriteSingleCoilResponse) {</span>
            // TODO: finish implementation
<span class="fc" id="L248">            WriteSingleCoilResponse writeSingleCoilResponse = (WriteSingleCoilResponse) modbusPdu;</span>
<span class="fc" id="L249">            LOGGER.debug(&quot;{}: address:{}, value:{}&quot;, writeSingleCoilResponse, writeSingleCoilResponse.getAddress(), writeSingleCoilResponse.getValue());</span>
<span class="fc" id="L250">            Map&lt;String, PlcResponseCode&gt; responseValues = new HashMap&lt;&gt;();</span>
<span class="fc" id="L251">            responseValues.put(fieldName, PlcResponseCode.OK);</span>
<span class="fc" id="L252">            plcRequestContainer.getResponseFuture().complete(new DefaultPlcWriteResponse((InternalPlcWriteRequest) request, responseValues));</span>
<span class="fc bfc" id="L253" title="All 2 branches covered.">        } else if (modbusPdu instanceof WriteSingleRegisterResponse) {</span>
            // TODO: finish implementation
<span class="fc" id="L255">            WriteSingleRegisterResponse writeSingleRegisterResponse = (WriteSingleRegisterResponse) modbusPdu;</span>
<span class="fc" id="L256">            LOGGER.debug(&quot;{}: address:{}, value:{}&quot;, writeSingleRegisterResponse, writeSingleRegisterResponse.getAddress(), writeSingleRegisterResponse.getValue());</span>
<span class="fc" id="L257">            Map&lt;String, PlcResponseCode&gt; responseValues = new HashMap&lt;&gt;();</span>
<span class="fc" id="L258">            responseValues.put(fieldName, PlcResponseCode.OK);</span>
<span class="fc" id="L259">            plcRequestContainer.getResponseFuture().complete(new DefaultPlcWriteResponse((InternalPlcWriteRequest) request, responseValues));</span>
<span class="fc bfc" id="L260" title="All 2 branches covered.">        } else if (modbusPdu instanceof ReadCoilsResponse) {</span>
            // TODO: finish implementation
<span class="fc" id="L262">            ReadCoilsResponse readCoilsResponse = (ReadCoilsResponse) modbusPdu;</span>
<span class="fc" id="L263">            LOGGER.debug(&quot;{}: Nothing&quot;, readCoilsResponse);</span>
<span class="fc" id="L264">            ByteBuf byteBuf = readCoilsResponse.getCoilStatus();</span>
<span class="fc" id="L265">            DefaultBooleanFieldItem data = produceCoilValueList(byteBuf, field.getQuantity());</span>
<span class="fc" id="L266">            Map&lt;String, Pair&lt;PlcResponseCode, BaseDefaultFieldItem&gt;&gt; responseValues = new HashMap&lt;&gt;();</span>
<span class="fc" id="L267">            responseValues.put(fieldName, new ImmutablePair&lt;&gt;(PlcResponseCode.OK, data));</span>
<span class="fc" id="L268">            plcRequestContainer.getResponseFuture().complete(new DefaultPlcReadResponse((InternalPlcReadRequest) request, responseValues));</span>
<span class="fc bfc" id="L269" title="All 2 branches covered.">        } else if (modbusPdu instanceof ReadDiscreteInputsResponse) {</span>
            // TODO: finish implementation
<span class="fc" id="L271">            ReadDiscreteInputsResponse readDiscreteInputsResponse = (ReadDiscreteInputsResponse) modbusPdu;</span>
<span class="fc" id="L272">            LOGGER.debug(&quot;{}: Nothing&quot;, readDiscreteInputsResponse);</span>
<span class="fc" id="L273">            ByteBuf byteBuf = readDiscreteInputsResponse.getInputStatus();</span>
<span class="fc" id="L274">            DefaultBooleanFieldItem data = produceCoilValueList(byteBuf, field.getQuantity());</span>
<span class="fc" id="L275">            Map&lt;String, Pair&lt;PlcResponseCode, BaseDefaultFieldItem&gt;&gt; responseValues = new HashMap&lt;&gt;();</span>
<span class="fc" id="L276">            responseValues.put(fieldName, new ImmutablePair&lt;&gt;(PlcResponseCode.OK, data));</span>
<span class="fc" id="L277">            plcRequestContainer.getResponseFuture().complete(new DefaultPlcReadResponse((InternalPlcReadRequest) request, responseValues));</span>
<span class="fc bfc" id="L278" title="All 2 branches covered.">        } else if (modbusPdu instanceof ReadHoldingRegistersResponse) {</span>
            // TODO: finish implementation
<span class="fc" id="L280">            ReadHoldingRegistersResponse readHoldingRegistersResponse = (ReadHoldingRegistersResponse) modbusPdu;</span>
<span class="fc" id="L281">            LOGGER.debug(&quot;{}: Nothing&quot;, readHoldingRegistersResponse);</span>
<span class="fc" id="L282">            ByteBuf byteBuf = readHoldingRegistersResponse.getRegisters();</span>
            // TODO: use register method
<span class="fc" id="L284">            DefaultModbusByteArrayFieldItem data = produceRegisterValueList(byteBuf, field.getQuantity());</span>
<span class="fc" id="L285">            Map&lt;String, Pair&lt;PlcResponseCode, BaseDefaultFieldItem&gt;&gt; responseValues = new HashMap&lt;&gt;();</span>
<span class="fc" id="L286">            responseValues.put(fieldName, new ImmutablePair&lt;&gt;(PlcResponseCode.OK, data));</span>
<span class="fc" id="L287">            plcRequestContainer.getResponseFuture().complete(new DefaultPlcReadResponse((InternalPlcReadRequest) request, responseValues));</span>
<span class="fc bfc" id="L288" title="All 2 branches covered.">        } else if (modbusPdu instanceof ReadInputRegistersResponse) {</span>
            // TODO: finish implementation
<span class="fc" id="L290">            ReadInputRegistersResponse readInputRegistersResponse = (ReadInputRegistersResponse) modbusPdu;</span>
<span class="fc" id="L291">            LOGGER.debug(&quot;{}: Nothing&quot;, readInputRegistersResponse);</span>
<span class="fc" id="L292">            ByteBuf byteBuf = readInputRegistersResponse.getRegisters();</span>
            // TODO: use register method
<span class="fc" id="L294">            DefaultModbusByteArrayFieldItem data = produceRegisterValueList(byteBuf, field.getQuantity());</span>
<span class="fc" id="L295">            Map&lt;String, Pair&lt;PlcResponseCode, BaseDefaultFieldItem&gt;&gt; responseValues = new HashMap&lt;&gt;();</span>
<span class="fc" id="L296">            responseValues.put(fieldName, new ImmutablePair&lt;&gt;(PlcResponseCode.OK, data));</span>
<span class="fc" id="L297">            plcRequestContainer.getResponseFuture().complete(new DefaultPlcReadResponse((InternalPlcReadRequest) request, responseValues));</span>
<span class="pc bpc" id="L298" title="1 of 2 branches missed.">        } else if (modbusPdu instanceof MaskWriteRegisterResponse) {</span>
            // TODO: finish implementation
<span class="fc" id="L300">            MaskWriteRegisterResponse maskWriteRegisterResponse = (MaskWriteRegisterResponse) modbusPdu;</span>
<span class="fc" id="L301">            LOGGER.debug(&quot;{}: Nothing&quot;, maskWriteRegisterResponse);</span>
<span class="fc" id="L302">            Map&lt;String, PlcResponseCode&gt; responseValues = new HashMap&lt;&gt;();</span>
<span class="fc" id="L303">            responseValues.put(fieldName, PlcResponseCode.OK);</span>
<span class="fc" id="L304">            plcRequestContainer.getResponseFuture().complete(new DefaultPlcWriteResponse((InternalPlcWriteRequest) request, responseValues));</span>
<span class="pc bnc" id="L305" title="All 2 branches missed.">        } else if (modbusPdu instanceof ExceptionResponse) {</span>
<span class="nc" id="L306">            ExceptionResponse exceptionResponse = (ExceptionResponse) modbusPdu;</span>
<span class="nc" id="L307">            throw new PlcProtocolException(&quot;Error received &quot; + exceptionResponse.getExceptionCode());</span>
        } else {
<span class="nc" id="L309">            throw new PlcProtocolException(&quot;Unsupported messageTyp type&quot; + modbusPdu.getClass());</span>
        }
<span class="fc" id="L311">    }</span>

    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
<span class="nc" id="L315">        LOGGER.trace(&quot;(--&gt;ERR): {}&quot;, ctx, cause);</span>
<span class="nc" id="L316">        super.exceptionCaught(ctx, cause);</span>
<span class="nc" id="L317">    }</span>

    ////////////////////////////////////////////////////////////////////////////////
    // Encoding helpers.
    ////////////////////////////////////////////////////////////////////////////////

    private boolean produceCoilValue(List&lt;?&gt; values) throws PlcProtocolException {
<span class="pc bpc" id="L324" title="1 of 2 branches missed.">        if (values.size() != 1) {</span>
<span class="nc" id="L325">            throw new PlcProtocolException(&quot;Only one value allowed&quot;);</span>
        }
<span class="fc" id="L327">        byte multiCoil = produceCoilValues(values)[0];</span>
<span class="pc bpc" id="L328" title="1 of 2 branches missed.">        return multiCoil != 0;</span>
    }

    private byte[] produceCoilValues(List&lt;?&gt; values) throws PlcProtocolException {
<span class="fc" id="L332">        List&lt;Byte&gt; coils = new LinkedList&lt;&gt;();</span>
<span class="fc" id="L333">        byte actualCoil = 0;</span>
<span class="fc" id="L334">        int i = 7;</span>
<span class="fc bfc" id="L335" title="All 2 branches covered.">        for (Object value : values) {</span>
            final boolean coilSet;
<span class="pc bpc" id="L337" title="1 of 2 branches missed.">            if (value.getClass() == Boolean.class) {</span>
<span class="nc" id="L338">                coilSet = (Boolean) value;</span>
<span class="pc bpc" id="L339" title="1 of 2 branches missed.">            } else if (value.getClass() == Byte.class) {</span>
<span class="nc bnc" id="L340" title="All 2 branches missed.">                if ((byte) value &gt; 1) {</span>
<span class="nc" id="L341">                    throw new PlcProtocolException(&quot;Value to high to fit into Byte: &quot; + value);</span>
                }
<span class="nc bnc" id="L343" title="All 2 branches missed.">                coilSet = (byte) value == 1;</span>
<span class="pc bpc" id="L344" title="1 of 2 branches missed.">            } else if (value.getClass() == byte[].class) {</span>
<span class="nc" id="L345">                byte[] bytes = (byte[]) value;</span>
<span class="nc bnc" id="L346" title="All 2 branches missed.">                if (bytes.length != 1) {</span>
<span class="nc" id="L347">                    throw new PlcProtocolException(&quot;Exactly one byte is allowed: &quot; + bytes.length);</span>
                }
<span class="nc" id="L349">                byte byteValue = bytes[0];</span>
<span class="nc bnc" id="L350" title="All 2 branches missed.">                if (byteValue &gt; 1) {</span>
<span class="nc" id="L351">                    throw new PlcProtocolException(&quot;Value to high to fit into Byte: &quot; + value);</span>
                }
<span class="nc bnc" id="L353" title="All 2 branches missed.">                coilSet = byteValue == 1;</span>
<span class="pc bpc" id="L354" title="1 of 2 branches missed.">            } else if (value.getClass() == Byte[].class) {</span>
<span class="fc" id="L355">                Byte[] bytes = (Byte[]) value;</span>
<span class="pc bpc" id="L356" title="1 of 2 branches missed.">                if (bytes.length != 1) {</span>
<span class="nc" id="L357">                    throw new PlcProtocolException(&quot;Exactly one byte is allowed: &quot; + bytes.length);</span>
                }
<span class="fc" id="L359">                byte byteValue = bytes[0];</span>
<span class="pc bpc" id="L360" title="1 of 2 branches missed.">                if (byteValue &gt; 1) {</span>
<span class="nc" id="L361">                    throw new PlcProtocolException(&quot;Value to high to fit into Byte: &quot; + value);</span>
                }
<span class="pc bpc" id="L363" title="1 of 2 branches missed.">                coilSet = byteValue == 1;</span>
<span class="pc bnc" id="L364" title="All 2 branches missed.">            } else if (value.getClass() == Short.class) {</span>
<span class="nc bnc" id="L365" title="All 2 branches missed.">                if ((short) value &gt; 1) {</span>
<span class="nc" id="L366">                    throw new PlcProtocolException(&quot;Value to high to fit into Byte: &quot; + value);</span>
                }
<span class="nc bnc" id="L368" title="All 2 branches missed.">                coilSet = (Short) value == 1;</span>
<span class="nc bnc" id="L369" title="All 2 branches missed.">            } else if (value.getClass() == Integer.class) {</span>
<span class="nc bnc" id="L370" title="All 2 branches missed.">                if ((int) value &gt; 1) {</span>
<span class="nc" id="L371">                    throw new PlcProtocolException(&quot;Value to high to fit into Byte: &quot; + value);</span>
                }
<span class="nc bnc" id="L373" title="All 2 branches missed.">                coilSet = (int) value == 1;</span>
<span class="nc bnc" id="L374" title="All 2 branches missed.">            } else if (value.getClass() == BigInteger.class) {</span>
<span class="nc" id="L375">                coilSet = value.equals(BigInteger.ONE);</span>
<span class="nc bnc" id="L376" title="All 2 branches missed.">            } else if (value.getClass() == Float.class) {</span>
<span class="nc" id="L377">                coilSet = value.equals(1.0f);</span>
<span class="nc bnc" id="L378" title="All 2 branches missed.">            } else if (value.getClass() == Double.class) {</span>
<span class="nc" id="L379">                coilSet = value.equals(1.0d);</span>
            } else {
<span class="nc" id="L381">                throw new PlcUnsupportedDataTypeException(value.getClass());</span>
            }
<span class="pc bpc" id="L383" title="1 of 2 branches missed.">            byte coilToSet = coilSet ? (byte) 1 : (byte) 0;</span>
<span class="fc" id="L384">            actualCoil = (byte) (actualCoil &amp; 0xff | coilToSet &lt;&lt; i);</span>
<span class="fc" id="L385">            i--;</span>
<span class="pc bpc" id="L386" title="1 of 2 branches missed.">            if (i &lt; 0) {</span>
<span class="nc" id="L387">                coils.add(actualCoil);</span>
<span class="nc" id="L388">                actualCoil = 0;</span>
<span class="nc" id="L389">                i = 8;</span>
            }
<span class="fc" id="L391">        }</span>
<span class="pc bpc" id="L392" title="1 of 2 branches missed.">        if (coils.isEmpty()) {</span>
            // We only have one coil
<span class="fc" id="L394">            return new byte[]{actualCoil};</span>
        }
<span class="nc" id="L396">        return ArrayUtils.toPrimitive(coils.toArray(new Byte[0]));</span>
    }

    private byte[] produceRegisterValue(List&lt;?&gt; values) throws PlcProtocolException {
<span class="fc" id="L400">        ByteBuf buffer = Unpooled.buffer();</span>
<span class="fc" id="L401">        long upperRegisterValue = 0xFFFFL;</span>
<span class="fc bfc" id="L402" title="All 2 branches covered.">        for (Object value : values) {</span>
<span class="pc bpc" id="L403" title="1 of 2 branches missed.">            if (value.getClass() == Boolean.class) {</span>
<span class="nc" id="L404">                buffer.writeByte(0);</span>
<span class="nc bnc" id="L405" title="All 2 branches missed.">                buffer.writeByte((boolean) value ? 1 : 0);</span>
<span class="pc bpc" id="L406" title="1 of 2 branches missed.">            } else if (value.getClass() == Byte.class) {</span>
<span class="nc" id="L407">                buffer.writeByte(0);</span>
<span class="nc" id="L408">                buffer.writeByte((byte) value);</span>
<span class="pc bpc" id="L409" title="1 of 2 branches missed.">            } else if (value.getClass() == byte[].class) {</span>
<span class="nc" id="L410">                byte[] bytes = (byte[]) value;</span>
<span class="nc bnc" id="L411" title="All 2 branches missed.">                if (bytes.length != 2) {</span>
<span class="nc" id="L412">                    throw new PlcProtocolException(&quot;Exactly two bytes are allowed: &quot; + bytes.length);</span>
                }
<span class="nc" id="L414">                buffer.writeBytes(bytes);</span>
<span class="pc bpc" id="L415" title="1 of 2 branches missed.">            } else if (value.getClass() == Byte[].class) {</span>
<span class="fc" id="L416">                Byte[] bytes = (Byte[]) value;</span>
<span class="pc bpc" id="L417" title="1 of 2 branches missed.">                if (bytes.length != 2) {</span>
<span class="nc" id="L418">                    throw new PlcProtocolException(&quot;Exactly two bytes are allowed: &quot; + bytes.length);</span>
                }
<span class="fc" id="L420">                buffer.writeBytes(ArrayUtils.toPrimitive(bytes));</span>
<span class="pc bnc" id="L421" title="All 2 branches missed.">            } else if (value.getClass() == Short.class) {</span>
<span class="nc bnc" id="L422" title="All 2 branches missed.">                if ((short) value &lt; 0) {</span>
<span class="nc" id="L423">                    throw new PlcProtocolException(&quot;Only positive values are supported for Short: &quot; + value);</span>
                }
<span class="nc" id="L425">                buffer.writeShort((short) value);</span>
<span class="nc bnc" id="L426" title="All 2 branches missed.">            } else if (value.getClass() == Integer.class) {</span>
<span class="nc bnc" id="L427" title="All 2 branches missed.">                if ((int) value &gt; upperRegisterValue) {</span>
<span class="nc" id="L428">                    throw new PlcProtocolException(&quot;Value to high to fit into register for Integer: &quot; + value);</span>
                }
<span class="nc bnc" id="L430" title="All 2 branches missed.">                if ((int) value &lt; 0) {</span>
<span class="nc" id="L431">                    throw new PlcProtocolException(&quot;Only positive values are supported for Integer: &quot; + value);</span>
                }
<span class="nc" id="L433">                buffer.writeShort((int) value);</span>
<span class="nc bnc" id="L434" title="All 2 branches missed.">            } else if (value.getClass() == BigInteger.class) {</span>
<span class="nc bnc" id="L435" title="All 2 branches missed.">                if (((BigInteger) value).compareTo(BigInteger.ZERO) &lt; 0) {</span>
<span class="nc" id="L436">                    throw new PlcProtocolException(&quot;Only positive values are supported for BigInteger: &quot; + value);</span>
                }
<span class="nc bnc" id="L438" title="All 2 branches missed.">                if (((BigInteger) value).compareTo(BigInteger.valueOf(0XFFFF_FFFFL)) &gt; 0) {</span>
<span class="nc" id="L439">                    throw new PlcProtocolException(&quot;Value to high to fit into register for BigInteger: &quot; + value);</span>
                }
                // TODO: for now we can't support big values as we only write one register at once
<span class="nc bnc" id="L442" title="All 2 branches missed.">                if (((BigInteger) value).compareTo(BigInteger.valueOf(upperRegisterValue)) &gt; 0) {</span>
<span class="nc" id="L443">                    throw new PlcProtocolException(&quot;Value to high to fit into register for BigInteger: &quot; + value);</span>
                }
                // TODO: Register has 2 bytes so we trim to 2 instead of 4 like the second if above
<span class="nc" id="L446">                int maxBytes = 2;</span>
<span class="nc" id="L447">                byte[] bigIntegerBytes = ((BigInteger) value).toByteArray();</span>
<span class="nc" id="L448">                byte[] bytes = new byte[maxBytes];</span>
<span class="nc" id="L449">                int lengthToCopy = Math.min(bigIntegerBytes.length, maxBytes);</span>
<span class="nc" id="L450">                int srcPosition = Math.max(bigIntegerBytes.length - maxBytes, 0);</span>
<span class="nc" id="L451">                int destPosition = maxBytes - lengthToCopy;</span>
<span class="nc" id="L452">                System.arraycopy(bigIntegerBytes, srcPosition, bytes, destPosition, lengthToCopy);</span>

                // TODO: check if this is a good representation.
                // TODO: can a big integer span multiple registers?
<span class="nc" id="L456">                buffer.writeBytes(bytes);</span>
<span class="nc bnc" id="L457" title="All 2 branches missed.">            } else if (value.getClass() == Float.class) {</span>
<span class="nc bnc" id="L458" title="All 2 branches missed.">                if (((float) value) &lt; 0) {</span>
<span class="nc" id="L459">                    throw new PlcProtocolException(&quot;Only positive values are supported for Float: &quot; + value);</span>
                }
<span class="nc bnc" id="L461" title="All 2 branches missed.">                if (((float) value) &gt; upperRegisterValue) {</span>
<span class="nc" id="L462">                    throw new PlcProtocolException(&quot;Value to high to fit into register for Float: &quot; + value);</span>
                }
<span class="nc" id="L464">                buffer.writeShort(Math.round((float) value));</span>
<span class="nc bnc" id="L465" title="All 2 branches missed.">            } else if (value.getClass() == Double.class) {</span>
<span class="nc bnc" id="L466" title="All 2 branches missed.">                if (((double) value) &lt; 0) {</span>
<span class="nc" id="L467">                    throw new PlcProtocolException(&quot;Only positive values are supported for Double: &quot; + value);</span>
                }
<span class="nc bnc" id="L469" title="All 2 branches missed.">                if (((double) value) &gt; upperRegisterValue) {</span>
<span class="nc" id="L470">                    throw new PlcProtocolException(&quot;Value to high to fit into register for Double: &quot; + value);</span>
                }
<span class="nc" id="L472">                buffer.writeShort((int) Math.round((double) value));</span>
            } else {
<span class="nc" id="L474">                throw new PlcUnsupportedDataTypeException(value.getClass());</span>
            }
<span class="fc" id="L476">        }</span>
<span class="fc" id="L477">        byte[] result = new byte[buffer.writerIndex()];</span>
<span class="fc" id="L478">        buffer.readBytes(result);</span>
<span class="fc" id="L479">        return result;</span>
    }

    ////////////////////////////////////////////////////////////////////////////////
    // Decoding helpers.
    ////////////////////////////////////////////////////////////////////////////////
    private DefaultBooleanFieldItem produceCoilValueList(ByteBuf byteBuf, int expectedQuantity) {
<span class="pc bpc" id="L486" title="1 of 2 branches missed.">        if (byteBuf.readableBytes() &lt; expectedQuantity / 8) {</span>
<span class="nc" id="L487">            LOGGER.warn(&quot;Expected to read {} coils but only max of {} can be supplied&quot;, expectedQuantity, byteBuf.readableBytes() * 8);</span>
        }
<span class="fc" id="L489">        byte[] bytes = new byte[byteBuf.readableBytes()];</span>
<span class="pc bpc" id="L490" title="1 of 2 branches missed.">        if (bytes.length &lt; 1) {</span>
<span class="nc" id="L491">            return new DefaultBooleanFieldItem();</span>
        }
<span class="fc" id="L493">        byteBuf.readBytes(bytes);</span>
<span class="fc" id="L494">        List&lt;Boolean&gt; data = new LinkedList&lt;&gt;();</span>
<span class="fc" id="L495">        int bitIndex = 0;</span>
<span class="fc" id="L496">        int coilIndex = 0;</span>
<span class="pc bpc" id="L497" title="1 of 4 branches missed.">        while (coilIndex &lt; bytes.length &amp;&amp; data.size() &lt; expectedQuantity) {</span>
<span class="pc bpc" id="L498" title="1 of 2 branches missed.">            if (bitIndex &gt; 7) {</span>
                // Every 8 Coils we need to increase the access
<span class="nc" id="L500">                coilIndex++;</span>
<span class="nc" id="L501">                bitIndex = 0;</span>
<span class="nc bnc" id="L502" title="All 2 branches missed.">                if (coilIndex &gt;= bytes.length) {</span>
<span class="nc" id="L503">                    break;</span>
                }
            }
<span class="pc bpc" id="L506" title="1 of 2 branches missed.">            boolean coilSet = (bytes[coilIndex] &amp; 0xff &amp; (1L &lt;&lt; bitIndex)) != 0;</span>
<span class="fc" id="L507">            data.add(coilSet);</span>
<span class="fc" id="L508">            bitIndex++;</span>
<span class="fc" id="L509">        }</span>
<span class="fc" id="L510">        return new DefaultBooleanFieldItem(data.toArray(new Boolean[0]));</span>
    }

    private DefaultModbusByteArrayFieldItem produceRegisterValueList(ByteBuf byteBuf, int expectedQuantity) throws PlcProtocolException {
<span class="fc" id="L514">        int readableBytes = byteBuf.readableBytes();</span>
<span class="pc bpc" id="L515" title="1 of 2 branches missed.">        if (readableBytes % 2 != 0) {</span>
<span class="nc" id="L516">            throw new PlcProtocolException(&quot;Readables bytes should even: &quot; + readableBytes);</span>
        }
<span class="fc" id="L518">        List&lt;Byte[]&gt; data = new LinkedList&lt;&gt;();</span>
<span class="fc bfc" id="L519" title="All 2 branches covered.">        while (byteBuf.readableBytes() &gt; 0) {</span>
<span class="fc" id="L520">            byte[] register = new byte[2];</span>
<span class="fc" id="L521">            byteBuf.readBytes(register);</span>
<span class="fc" id="L522">            data.add(ArrayUtils.toObject(register));</span>
<span class="fc" id="L523">        }</span>
<span class="fc" id="L524">        return new DefaultModbusByteArrayFieldItem(data.toArray(new Byte[0][0]));</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>